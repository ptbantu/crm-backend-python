# 价格生效时间业务逻辑说明

## 业务场景

1. **一个产品对应一条价格记录**：一条 `product_prices` 记录包含该产品的所有价格类型和货币（渠道价、直客价、列表价的IDR和CNY）
2. **价格修改需要提前公告**：管理员修改价格时，如果设置未来生效时间，需要提前公告给销售和相关人员
3. **时间线必须连续**：价格生效时间线必须连续，不能有重叠，也不能有空白（除非是未来生效的过渡期）

## 价格生效时间规则

### 规则1: 立即生效（effective_from = None 或 <= 当前时间）

**场景**: 管理员立即修改价格

**行为**:
- 当前有效价格的 `effective_to` = 当前时间
- 新价格的 `effective_from` = 当前时间
- 新价格的 `effective_to` = None（表示当前有效）

**时间线示例**:
```
旧价格: [2024-01-01 09:00:00 -----> 2024-01-01 10:00:00]
新价格:                                    [2024-01-01 10:00:00 -----> ∞]
```

### 规则2: 未来生效（effective_from > 当前时间）

**场景**: 管理员设置未来生效的价格，需要提前公告

**行为**:
- 当前有效价格的 `effective_to` = 新价格生效时间 - 1秒
- 新价格的 `effective_from` = 指定的未来时间
- 新价格的 `effective_to` = None（表示当前有效）

**时间线示例**:
```
当前时间: 2024-01-01 10:00:00
旧价格:   [2024-01-01 09:00:00 -----> 2024-01-02 09:59:59]
新价格:                                    [2024-01-02 10:00:00 -----> ∞]
```

**重要**: 
- 在旧价格失效和新价格生效之间，有1秒的过渡期（这是正常的，因为需要精确的时间边界）
- 查询时，如果查询时间在过渡期内，应该返回旧价格（因为 `effective_from <= query_time` 且 `effective_to >= query_time`）

### 规则3: 过去生效（effective_from < 当前时间）

**场景**: 历史价格修正（较少见，但需要支持）

**行为**:
- 检查在 `effective_from` 时间点是否有其他价格记录
- 如果有冲突，将冲突价格失效或删除
- 当前有效价格的 `effective_to` = 当前时间
- 新价格的 `effective_from` = 指定的过去时间
- 新价格的 `effective_to` = None（表示当前有效）

**时间线示例**:
```
当前时间: 2024-01-02 10:00:00
旧价格:   [2024-01-01 09:00:00 -----> 2024-01-02 10:00:00]
新价格:   [2024-01-01 08:00:00 -----> ∞]  (历史修正，覆盖旧价格)
```

### 规则4: 未来价格冲突检查

**场景**: 设置未来生效价格时，检查是否与现有未来价格冲突

**行为**:
- 如果存在相同 `effective_from` 的未来价格，抛出异常
- 如果存在不同 `effective_from` 的未来价格，需要调整时间线

**示例**:
```
当前时间: 2024-01-01 10:00:00
当前价格: [2024-01-01 09:00:00 -----> ∞]
未来价格1: [2024-01-02 10:00:00 -----> ∞]
设置新价格: effective_from = 2024-01-02 10:00:00  ❌ 冲突，抛出异常

设置新价格: effective_from = 2024-01-02 11:00:00  ✅ 允许
调整后:
当前价格:   [2024-01-01 09:00:00 -----> 2024-01-02 09:59:59]
未来价格1:  [2024-01-02 10:00:00 -----> 2024-01-02 10:59:59]
新价格:     [2024-01-02 11:00:00 -----> ∞]
```

## 查询逻辑

### 查询当前有效价格

**查询条件**:
```sql
WHERE product_id = ?
  AND organization_id = ? (或 IS NULL)
  AND effective_from <= NOW()
  AND (effective_to IS NULL OR effective_to >= NOW())
ORDER BY effective_from DESC
LIMIT 1
```

### 查询指定时间点的价格

**查询条件**:
```sql
WHERE product_id = ?
  AND organization_id = ? (或 IS NULL)
  AND effective_from <= ?
  AND (effective_to IS NULL OR effective_to >= ?)
ORDER BY effective_from DESC
LIMIT 1
```

## 边界情况处理

### 情况1: 多个未来价格

**场景**: 已经设置了多个未来生效的价格

**处理**:
- 当设置新的未来价格时，需要检查是否插入到现有未来价格之间
- 如果插入到中间，需要调整前后价格的 `effective_to`

**示例**:
```
当前时间: 2024-01-01 10:00:00
当前价格: [2024-01-01 09:00:00 -----> ∞]
未来价格1: [2024-01-02 10:00:00 -----> ∞]
未来价格2: [2024-01-03 10:00:00 -----> ∞]

设置新价格: effective_from = 2024-01-02 11:00:00

调整后:
当前价格:   [2024-01-01 09:00:00 -----> 2024-01-02 09:59:59]
未来价格1:  [2024-01-02 10:00:00 -----> 2024-01-02 10:59:59]
新价格:     [2024-01-02 11:00:00 -----> 2024-01-03 09:59:59]
未来价格2:  [2024-01-03 10:00:00 -----> ∞]
```

### 情况2: 相同生效时间的未来价格

**处理**: 抛出异常，不允许设置相同生效时间的未来价格

### 情况3: 过去生效价格与现有价格重叠

**处理**: 
- 如果冲突的价格是当前有效的，立即失效
- 如果冲突的价格是未来生效的，删除它

## 实施要点

1. **时间精度**: 使用秒级精度，`effective_to = effective_from - timedelta(seconds=1)` 确保无重叠
2. **查询优化**: 使用索引 `(product_id, organization_id, effective_from, effective_to)`
3. **日志记录**: 记录所有价格变更，包括生效时间变更
4. **验证**: 在创建/更新价格时，验证时间线连续性
