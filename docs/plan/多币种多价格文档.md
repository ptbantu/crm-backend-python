# 服务与供应商管理设计文档

**创建日期**: 2024-12-13  
**版本**: v2.0  
**状态**: 设计阶段

---

## 一、设计目标

基于现有 `schema_v1.sql` 数据库结构，重新设计服务和供应商管理环节，实现以下核心需求：

1. **多供应商支持**: 一个服务可以由多个供应商提供，支持供应商竞争和选择
2. **内部交付支持**: 公司内部团队也可以提供服务，支持内部交付和供应商交付两种模式
3. **成本价格版本控制**: 内部团队和外部供应商的成本价格都需要版本控制，价格变更不影响历史订单的成本核算
4. **销售价格分级体系**: 根据客户等级设置不同的对外销售价格，支持 CNY 和 IDR 双币种
5. **项目执行进度管理**: 标准执行时长、阶段划分、进度预警
6. **精确利润核算**: 支持成本价格（内部成本+供应商成本）、销售价格、浮动成本（报销）的精确归集

### 核心概念区分

**成本价格（Cost Price）**:
- **定义**: 内部团队或外部供应商提供服务的成本价格
- **提供方**: 内部团队（`organization_type='internal'`）或外部供应商（`organization_type='vendor'`）
- **版本控制**: 需要版本控制，价格变更不影响历史订单
- **存储表**: `supplier_cost_history`
- **用途**: 用于计算利润、选择服务提供方

**销售价格（Sales Price）**:
- **定义**: 对外销售给客户的价格
- **分级**: 根据客户等级（`customer_levels`）设置不同价格
- **版本控制**: 通过 `is_active` 和 `effective_from/effective_to` 控制生效时间
- **存储表**: `product_price_list`
- **用途**: 销售报价、订单定价

**利润计算**:
```
利润 = 销售价格（product_price_list）- 成本价格（supplier_cost_history）- 浮动成本（报销）
```

---

## 二、当前数据库结构分析

### 2.1 现有表结构

#### Products 表（产品/服务表）
- **问题**: 价格字段硬编码在表中（`price_cost_idr`, `price_channel_cny`, `price_direct_idr` 等）
- **问题**: 单一供应商关联（`vendor_id`），不支持多供应商
- **问题**: 缺少标准执行时长字段

#### Organizations 表（组织表）
- **类型**: `internal`（内部组织）、`vendor`（供应商）、`agent`（渠道商）
- **供应商**: `organization_type = 'vendor'` 的组织即为供应商
- **内部团队**: `organization_type = 'internal'` 的组织可以作为服务提供方（内部交付）
- **业务场景**: 一个服务可以选择内部交付（由内部团队执行）或供应商交付（外包给外部供应商）

#### Customer Levels 表（客户等级表）
- **等级代码**: `code` 字段（如 '2', '3', '4', '5', '6'）
- **等级名称**: 央企总部和龙头企业、国有企业和上市公司、非上市品牌公司、中小型企业、个人创业小公司

#### Order Items 表（订单项表）
- **当前**: 缺少供应商关联和成本快照字段

---

## 三、核心设计思路

### 3.1 产品表瘦身

**原则**: 产品表只保留基础属性，价格和供应商关系剥离到独立表

**修改**:
- 保留产品基础信息（名称、编码、分类、描述等）
- 添加标准执行时长字段
- 添加是否允许多供应商标志
- **废弃**（标记为 deprecated）: 所有硬编码的价格字段

### 3.2 销售价格体系表 (`product_price_list`)

**设计**: 一个产品一条记录，包含四个固定客户等级的价格（简化维护）

**核心概念**:
- **销售价格**: 对外销售给客户的价格，根据客户等级分级
- **成本价格**: 由内部团队或外部供应商提供，存储在 `supplier_cost_history` 表中
- **简化设计**: 由于客户等级固定为4个（等级2、3、4、5、6），一条记录存储所有等级的价格，避免维护多条记录

**核心字段**:
- `product_id`: 产品ID
- `price_level2_cny/idr`: 等级2价格（央企总部和龙头企业）
- `price_level3_cny/idr`: 等级3价格（国有企业和上市公司）
- `price_level4_cny/idr`: 等级4价格（非上市品牌公司）
- `price_level5_cny/idr`: 等级5价格（中小型企业）
- `price_level6_cny/idr`: 等级6价格（个人创业小公司）
- `is_active`: 是否启用
- `effective_from`: 生效开始时间
- `effective_to`: 生效结束时间

**业务规则**:
- 一个产品只有一条价格记录（包含所有等级的价格）
- 支持价格生效时间控制（通过 `is_active` 和 `effective_from/effective_to`）
- **注意**: 这是对外销售价格，不是成本价格。成本价格由内部团队或外部供应商在 `supplier_cost_history` 表中提供
- **优势**: 简化维护，一个产品只需维护一条记录，而不是4-5条记录

### 3.3 服务提供方成本价格版本控制表 (`supplier_cost_history`)

**设计**: 记录服务提供方（包括外部供应商和内部团队）对每个服务的**成本价格**历史，支持版本控制

**核心概念**:
- **成本价格**: 内部团队或外部供应商提供服务的成本价格（不是销售价格）
- **外部供应商**: `organization_type = 'vendor'` 的组织，提供供应商成本价格
- **内部团队**: `organization_type = 'internal'` 的组织（如：企业服务组、签证组、财税组、猎头组），提供内部成本价格
- **统一管理**: 无论是内部交付还是供应商交付，都使用同一张表记录成本价格，通过 `supplier_id` 关联的组织类型区分
- **版本控制**: 成本价格变更时创建新版本，历史订单的成本价格不受影响

**核心字段**:
- `product_id`: 服务ID
- `supplier_id`: 服务提供方ID（可以是 `organizations.id` where `organization_type='vendor'` 或 `organization_type='internal'`）
- `delivery_type`: 交付类型（`INTERNAL`=内部交付，`VENDOR`=供应商交付）
- `version`: 版本号（同一服务提供方同一服务的版本号递增）
- `cost_cny`: 人民币成本价格
- `cost_idr`: 印尼盾成本价格
- `effective_start_at`: 生效开始时间
- `effective_end_at`: 失效时间（NULL 表示当前有效）
- `is_current`: 是否为当前最新成本价格
- `notes`: 备注说明（如：涨价原因、内部成本计算方式等）

**业务规则**:
- 同一服务提供方对同一服务在同一时间段只能有一个有效成本价格
- 新成本价格创建时，自动将旧成本价格的 `effective_end_at` 设为新成本价格的 `effective_start_at`，`is_current` 设为 0
- 订单创建时，必须关联到具体的成本价格版本记录 ID
- **内部交付成本价格**: 内部团队的成本价格（人力成本、时间成本等转换为货币成本）
- **供应商交付成本价格**: 外部供应商的成本价格（供应商报价）
- **版本控制**: 成本价格变更时创建新版本，确保历史订单的成本价格不变

### 3.4 服务执行阶段模板表 (`service_stage_templates`)

**设计**: 定义每个服务的标准执行流程和阶段时长

**核心字段**:
- `product_id`: 服务ID
- `stage_name`: 阶段名称（如：资料收集、任务执行、提交审批、任务完成）
- `stage_order`: 排序（1, 2, 3, 4）
- `standard_days`: 该阶段标准耗时（天）
- `is_milestone`: 是否为关键里程碑

**业务规则**:
- 每个服务至少需要定义一个阶段模板
- 阶段顺序必须连续（1, 2, 3, 4...）
- 标准执行总时长 = 所有阶段 `standard_days` 之和

### 3.5 订单项扩展 (`order_items`)

**设计**: 在订单项中记录服务提供方选择和成本快照

**新增字段**:
- `selected_supplier_id`: 执行该项的服务提供方ID（可以是内部团队或外部供应商）
- `delivery_type`: 交付类型（`INTERNAL`=内部交付，`VENDOR`=供应商交付）
- `supplier_cost_history_id`: 关联的成本版本ID
- `snapshot_cost_cny`: 下单时的RMB成本快照
- `snapshot_cost_idr`: 下单时的IDR成本快照
- `estimated_profit_cny`: 预估毛利（CNY）（计算字段）

**业务规则**:
- 订单创建时，必须选择服务提供方（内部团队或外部供应商）并记录成本快照
- 成本快照用于利润核算，不受后续服务提供方报价变更影响
- **内部交付**: 选择内部团队时，`delivery_type = 'INTERNAL'`，成本可能是人力成本
- **供应商交付**: 选择外部供应商时，`delivery_type = 'VENDOR'`，成本是供应商报价

---

## 四、数据库 Schema 设计

### 4.1 修改产品表 (`products`)

```sql
-- 添加标准执行时长和多供应商支持字段
ALTER TABLE `products` 
ADD COLUMN `std_duration_days` INT DEFAULT 7 COMMENT '标准执行总时长(天)',
ADD COLUMN `allow_multi_vendor` TINYINT(1) DEFAULT 1 COMMENT '是否允许多供应商接单（1=允许，0=单一供应商）',
ADD COLUMN `default_supplier_id` CHAR(36) DEFAULT NULL COMMENT '默认供应商ID（当allow_multi_vendor=0时使用）';

-- 添加外键约束
ALTER TABLE `products`
ADD CONSTRAINT `fk_products_default_supplier` 
FOREIGN KEY (`default_supplier_id`) REFERENCES `organizations` (`id`) ON DELETE SET NULL;

-- 注意：旧的价格字段（price_cost_idr, price_channel_cny等）保留但不使用
-- 未来可以通过数据迁移脚本将历史数据迁移到新表后删除
```

### 4.2 创建销售价格体系表 (`product_price_list`)

**设计说明**: 
- 一个产品对应四个固定客户等级的价格，用**一条记录**存储
- 客户等级固定为：2(央企总部和龙头企业), 3(国有企业和上市公司), 4(非上市品牌公司), 5(中小型企业), 6(个人创业小公司)
- 简化维护：不需要为每个等级创建多条记录，一条记录包含所有等级的价格

```sql
DROP TABLE IF EXISTS `product_price_list`;

CREATE TABLE `product_price_list` (
  `id` CHAR(36) NOT NULL DEFAULT (UUID()),
  `product_id` CHAR(36) NOT NULL COMMENT '关联服务/产品ID',
  
  -- 四个固定客户等级的价格（CNY）
  `price_level2_cny` DECIMAL(18,2) DEFAULT '0.00' COMMENT '等级2价格(CNY): 央企总部和龙头企业',
  `price_level3_cny` DECIMAL(18,2) DEFAULT '0.00' COMMENT '等级3价格(CNY): 国有企业和上市公司',
  `price_level4_cny` DECIMAL(18,2) DEFAULT '0.00' COMMENT '等级4价格(CNY): 非上市品牌公司',
  `price_level5_cny` DECIMAL(18,2) DEFAULT '0.00' COMMENT '等级5价格(CNY): 中小型企业',
  `price_level6_cny` DECIMAL(18,2) DEFAULT '0.00' COMMENT '等级6价格(CNY): 个人创业小公司',
  
  -- 四个固定客户等级的价格（IDR）
  `price_level2_idr` DECIMAL(18,2) DEFAULT '0.00' COMMENT '等级2价格(IDR): 央企总部和龙头企业',
  `price_level3_idr` DECIMAL(18,2) DEFAULT '0.00' COMMENT '等级3价格(IDR): 国有企业和上市公司',
  `price_level4_idr` DECIMAL(18,2) DEFAULT '0.00' COMMENT '等级4价格(IDR): 非上市品牌公司',
  `price_level5_idr` DECIMAL(18,2) DEFAULT '0.00' COMMENT '等级5价格(IDR): 中小型企业',
  `price_level6_idr` DECIMAL(18,2) DEFAULT '0.00' COMMENT '等级6价格(IDR): 个人创业小公司',
  
  -- 价格状态和生效时间
  `is_active` TINYINT(1) DEFAULT '1' COMMENT '是否启用',
  `effective_from` DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '生效开始时间',
  `effective_to` DATETIME DEFAULT NULL COMMENT '生效结束时间（NULL表示一直有效）',
  
  `created_by` CHAR(36) DEFAULT NULL COMMENT '创建人ID',
  `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  
  PRIMARY KEY (`id`),
  -- 确保同一个产品只有一个有效价格条目
  UNIQUE KEY `ux_product_active` (`product_id`, `is_active`),
  KEY `ix_price_list_product` (`product_id`),
  KEY `ix_price_list_active` (`is_active`),
  KEY `ix_price_list_effective` (`effective_from`, `effective_to`),
  CONSTRAINT `fk_price_list_product` FOREIGN KEY (`product_id`) REFERENCES `products` (`id`) ON DELETE CASCADE,
  CONSTRAINT `fk_price_list_creator` FOREIGN KEY (`created_by`) REFERENCES `users` (`id`) ON DELETE SET NULL,
  CONSTRAINT `chk_price_nonneg` CHECK (
    (COALESCE(`price_level2_cny`, 0) >= 0) AND 
    (COALESCE(`price_level3_cny`, 0) >= 0) AND 
    (COALESCE(`price_level4_cny`, 0) >= 0) AND 
    (COALESCE(`price_level5_cny`, 0) >= 0) AND 
    (COALESCE(`price_level6_cny`, 0) >= 0) AND
    (COALESCE(`price_level2_idr`, 0) >= 0) AND 
    (COALESCE(`price_level3_idr`, 0) >= 0) AND 
    (COALESCE(`price_level4_idr`, 0) >= 0) AND 
    (COALESCE(`price_level5_idr`, 0) >= 0) AND 
    (COALESCE(`price_level6_idr`, 0) >= 0)
  )
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='销售价格体系表：一个产品一条记录，包含四个固定客户等级的价格';
```

### 4.3 创建服务提供方成本版本表 (`supplier_cost_history`)

**表名说明**: 虽然表名为 `supplier_cost_history`，但实际上同时支持外部供应商和内部团队的成本管理。

```sql
DROP TABLE IF EXISTS `supplier_cost_history`;

CREATE TABLE `supplier_cost_history` (
  `id` CHAR(36) NOT NULL DEFAULT (UUID()),
  `product_id` CHAR(36) NOT NULL COMMENT '关联服务ID',
  `supplier_id` CHAR(36) NOT NULL COMMENT '关联服务提供方ID (可以是 organizations表 type=vendor 或 type=internal)',
  `delivery_type` ENUM('INTERNAL', 'VENDOR') NOT NULL COMMENT '交付类型: INTERNAL=内部交付, VENDOR=供应商交付',
  `version` INT NOT NULL DEFAULT 1 COMMENT '版本号（同一服务提供方同一服务的版本号递增）',
  `cost_cny` DECIMAL(18,2) DEFAULT '0.00' COMMENT '人民币成本',
  `cost_idr` DECIMAL(18,2) DEFAULT '0.00' COMMENT '印尼盾成本',
  `effective_start_at` DATETIME NOT NULL COMMENT '生效开始时间',
  `effective_end_at` DATETIME DEFAULT NULL COMMENT '失效时间 (NULL代表当前一直有效)',
  `is_current` TINYINT(1) DEFAULT '1' COMMENT '是否为当前最新报价',
  `notes` TEXT COMMENT '备注说明（如：涨价原因、特殊条件、内部成本计算方式等）',
  `created_by` CHAR(36) DEFAULT NULL COMMENT '创建人ID',
  `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `ix_cost_lookup` (`product_id`, `supplier_id`, `is_current`),
  KEY `ix_cost_product` (`product_id`),
  KEY `ix_cost_supplier` (`supplier_id`),
  KEY `ix_cost_delivery_type` (`delivery_type`),
  KEY `ix_cost_effective` (`effective_start_at`, `effective_end_at`),
  CONSTRAINT `fk_cost_product` FOREIGN KEY (`product_id`) REFERENCES `products` (`id`) ON DELETE CASCADE,
  CONSTRAINT `fk_cost_supplier` FOREIGN KEY (`supplier_id`) REFERENCES `organizations` (`id`) ON DELETE CASCADE,
  CONSTRAINT `fk_cost_creator` FOREIGN KEY (`created_by`) REFERENCES `users` (`id`) ON DELETE SET NULL,
  -- 确保同一服务提供方同一服务在同一时间段只有一个有效报价
  CONSTRAINT `chk_cost_nonneg` CHECK (
    (COALESCE(`cost_cny`, 0) >= 0) AND 
    (COALESCE(`cost_idr`, 0) >= 0)
  ),
  -- 确保 delivery_type 与 organizations.organization_type 一致
  -- 注意：这个约束需要在应用层保证，数据库层面难以实现跨表检查
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='服务提供方成本历史表(版本控制，支持内部交付和供应商交付)';
```

### 4.4 创建服务执行阶段模板表 (`service_stage_templates`)

```sql
DROP TABLE IF EXISTS `service_stage_templates`;

CREATE TABLE `service_stage_templates` (
  `id` CHAR(36) NOT NULL DEFAULT (UUID()),
  `product_id` CHAR(36) NOT NULL COMMENT '关联服务ID',
  `stage_name_zh` VARCHAR(100) NOT NULL COMMENT '阶段名称（中文）',
  `stage_name_id` VARCHAR(100) DEFAULT NULL COMMENT '阶段名称（印尼语）',
  `stage_order` INT NOT NULL COMMENT '排序 (1,2,3,4...)',
  `standard_days` INT DEFAULT 0 COMMENT '该阶段标准耗时(天)',
  `is_milestone` TINYINT(1) DEFAULT '0' COMMENT '是否为关键里程碑',
  `description` TEXT COMMENT '阶段描述',
  `created_by` CHAR(36) DEFAULT NULL COMMENT '创建人ID',
  `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `ix_stage_tpl_product` (`product_id`),
  KEY `ix_stage_tpl_order` (`product_id`, `stage_order`),
  CONSTRAINT `fk_stage_tpl_product` FOREIGN KEY (`product_id`) REFERENCES `products` (`id`) ON DELETE CASCADE,
  CONSTRAINT `fk_stage_tpl_creator` FOREIGN KEY (`created_by`) REFERENCES `users` (`id`) ON DELETE SET NULL,
  CONSTRAINT `chk_stage_order_positive` CHECK (`stage_order` > 0),
  CONSTRAINT `chk_stage_days_nonneg` CHECK (`standard_days` >= 0)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='服务执行阶段标准模板';
```

### 4.5 修改订单项表 (`order_items`)

```sql
-- 添加服务提供方选择和成本快照字段
ALTER TABLE `order_items`
-- 1. 记录选择了哪个服务提供方（内部团队或外部供应商）
ADD COLUMN `selected_supplier_id` CHAR(36) DEFAULT NULL COMMENT '执行该项的服务提供方ID（可以是内部团队或外部供应商）',

-- 2. 交付类型（明确是内部交付还是供应商交付）
ADD COLUMN `delivery_type` ENUM('INTERNAL', 'VENDOR') DEFAULT NULL COMMENT '交付类型: INTERNAL=内部交付, VENDOR=供应商交付',

-- 3. 核心：记录成本来源的版本ID (关联 supplier_cost_history.id)
ADD COLUMN `supplier_cost_history_id` CHAR(36) DEFAULT NULL COMMENT '关联的成本版本ID',

-- 4. 成本快照 (双重保险，防止历史表被删，直接把金额固化在订单行里)
ADD COLUMN `snapshot_cost_cny` DECIMAL(18,2) DEFAULT '0.00' COMMENT '下单时的RMB成本快照',
ADD COLUMN `snapshot_cost_idr` DECIMAL(18,2) DEFAULT '0.00' COMMENT '下单时的IDR成本快照',

-- 5. 利润字段（存储字段，便于报表查询）
ADD COLUMN `estimated_profit_cny` DECIMAL(18,2) DEFAULT '0.00' COMMENT '预估毛利(CNY)',
ADD COLUMN `estimated_profit_idr` DECIMAL(18,2) DEFAULT '0.00' COMMENT '预估毛利(IDR)';

-- 添加外键约束
ALTER TABLE `order_items`
ADD CONSTRAINT `fk_order_item_supplier` 
FOREIGN KEY (`selected_supplier_id`) REFERENCES `organizations` (`id`) ON DELETE SET NULL,

ADD CONSTRAINT `fk_order_item_cost_ver` 
FOREIGN KEY (`supplier_cost_history_id`) REFERENCES `supplier_cost_history` (`id`) ON DELETE SET NULL;

-- 添加索引
ALTER TABLE `order_items`
ADD KEY `ix_order_items_supplier` (`selected_supplier_id`),
ADD KEY `ix_order_items_delivery_type` (`delivery_type`),
ADD KEY `ix_order_items_cost_history` (`supplier_cost_history_id`);

-- 添加检查约束：确保 delivery_type 和 selected_supplier_id 同时存在或同时为空
ALTER TABLE `order_items`
ADD CONSTRAINT `chk_order_items_delivery` 
CHECK (
  (`selected_supplier_id` IS NULL AND `delivery_type` IS NULL) OR
  (`selected_supplier_id` IS NOT NULL AND `delivery_type` IS NOT NULL)
);
```

### 4.6 修改订单阶段表 (`order_stages`) 以支持进度预警

**设计说明**: 
- 根据业务需求，订单阶段应该关联到**订单项**（`order_items`），而不是整个订单
- 因为一个订单可能包含多个服务项，每个服务项的执行进度是独立的
- 如果 `order_item_id` 为空，则阶段关联到整个订单（向后兼容）

```sql
-- 添加订单项关联（核心：阶段应该关联到具体的订单项）
ALTER TABLE `order_stages`
ADD COLUMN `order_item_id` CHAR(36) DEFAULT NULL COMMENT '关联的订单项ID（核心字段，阶段关联到具体的服务项）';

-- 添加进度预警字段
ALTER TABLE `order_stages`
ADD COLUMN `expected_start_date` DATE DEFAULT NULL COMMENT '预期开始日期',
ADD COLUMN `expected_end_date` DATE DEFAULT NULL COMMENT '预期结束日期(根据标准时长计算)',
ADD COLUMN `actual_start_date` DATE DEFAULT NULL COMMENT '实际开始日期',
ADD COLUMN `actual_end_date` DATE DEFAULT NULL COMMENT '实际结束日期',
ADD COLUMN `is_overdue` TINYINT(1) DEFAULT '0' COMMENT '是否已超期',
ADD COLUMN `alert_level` VARCHAR(20) DEFAULT 'normal' COMMENT '预警级别: normal, warning, critical',
ADD COLUMN `stage_template_id` CHAR(36) DEFAULT NULL COMMENT '关联的阶段模板ID';

-- 添加外键约束
ALTER TABLE `order_stages`
ADD CONSTRAINT `fk_order_stage_order_item` 
FOREIGN KEY (`order_item_id`) REFERENCES `order_items` (`id`) ON DELETE CASCADE,

ADD CONSTRAINT `fk_order_stage_template` 
FOREIGN KEY (`stage_template_id`) REFERENCES `service_stage_templates` (`id`) ON DELETE SET NULL;

-- 添加索引
ALTER TABLE `order_stages`
ADD KEY `ix_order_stages_order_item` (`order_item_id`),
ADD KEY `ix_order_stages_expected` (`expected_end_date`),
ADD KEY `ix_order_stages_overdue` (`is_overdue`),
ADD KEY `ix_order_stages_alert` (`alert_level`);

-- 添加检查约束：确保 order_id 和 order_item_id 至少有一个不为空
ALTER TABLE `order_stages`
ADD CONSTRAINT `chk_order_stages_reference` 
CHECK (`order_id` IS NOT NULL);
```

### 4.7 创建文件存储表 (`file_storage`)

**设计**: 统一管理所有文件（报销凭证、合同、订单文件等）的元数据信息

**核心概念**:
- **文件存储**: 文件实际存储在OSS，数据库中存储文件的完整元数据信息
- **文件类型**: 支持报销凭证、合同、订单文件、服务文档等多种类型
- **元数据**: 包含文件名、大小、MD5、创建时间、OSS地址等完整信息

**核心字段**:
- `id`: 文件ID（UUID）
- `file_name`: 原始文件名
- `file_type`: 文件类型（报销凭证、合同、订单文件等）
- `file_size`: 文件大小（字节）
- `file_md5`: 文件MD5值（用于校验文件完整性）
- `mime_type`: MIME类型（如：image/jpeg, application/pdf）
- `oss_bucket`: OSS存储桶名称
- `oss_key`: OSS对象键（文件路径）
- `oss_url`: OSS访问URL（完整URL）
- `business_type`: 业务类型（expense=报销, contract=合同, order=订单等）
- `business_id`: 业务对象ID（关联到具体的业务记录）
- `uploaded_by`: 上传人ID
- `description`: 文件描述

```sql
DROP TABLE IF EXISTS `file_storage`;

CREATE TABLE `file_storage` (
  `id` CHAR(36) NOT NULL DEFAULT (UUID()),
  `file_name` VARCHAR(255) NOT NULL COMMENT '原始文件名',
  `file_type` VARCHAR(50) NOT NULL COMMENT '文件类型: EXPENSE_PROOF(报销凭证), CONTRACT(合同), ORDER_FILE(订单文件), SERVICE_DOC(服务文档)',
  `file_size` BIGINT NOT NULL COMMENT '文件大小（字节）',
  `file_md5` VARCHAR(32) NOT NULL COMMENT '文件MD5值（用于校验文件完整性）',
  `mime_type` VARCHAR(100) DEFAULT NULL COMMENT 'MIME类型（如：image/jpeg, application/pdf）',
  `file_extension` VARCHAR(20) DEFAULT NULL COMMENT '文件扩展名（如：jpg, pdf, docx）',
  
  -- OSS存储信息
  `oss_bucket` VARCHAR(100) NOT NULL COMMENT 'OSS存储桶名称',
  `oss_key` VARCHAR(500) NOT NULL COMMENT 'OSS对象键（文件路径）',
  `oss_url` VARCHAR(1000) NOT NULL COMMENT 'OSS访问URL（完整URL，支持CDN加速）',
  `oss_region` VARCHAR(50) DEFAULT NULL COMMENT 'OSS区域（如：ap-southeast-5）',
  
  -- 业务关联
  `business_type` VARCHAR(50) NOT NULL COMMENT '业务类型: EXPENSE(报销), CONTRACT(合同), ORDER(订单), ORDER_ITEM(订单项), SERVICE(服务)',
  `business_id` CHAR(36) DEFAULT NULL COMMENT '业务对象ID（关联到具体的业务记录，如报销单ID、合同ID等）',
  
  -- 文件元数据
  `description` VARCHAR(500) DEFAULT NULL COMMENT '文件描述',
  `tags` JSON DEFAULT NULL COMMENT '文件标签（JSON数组，如：["发票", "2024年12月"]）',
  `is_public` TINYINT(1) DEFAULT '0' COMMENT '是否公开访问（0=私有, 1=公开）',
  
  -- 上传信息
  `uploaded_by` CHAR(36) NOT NULL COMMENT '上传人ID（关联 users.id）',
  `uploaded_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '上传时间',
  
  -- 文件状态
  `status` VARCHAR(20) DEFAULT 'ACTIVE' COMMENT '文件状态: ACTIVE(有效), DELETED(已删除), ARCHIVED(已归档)',
  `deleted_at` DATETIME DEFAULT NULL COMMENT '删除时间',
  `deleted_by` CHAR(36) DEFAULT NULL COMMENT '删除人ID',
  
  `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  
  PRIMARY KEY (`id`),
  UNIQUE KEY `ux_file_oss_key` (`oss_bucket`, `oss_key`),
  KEY `ix_file_business` (`business_type`, `business_id`),
  KEY `ix_file_type` (`file_type`),
  KEY `ix_file_md5` (`file_md5`),
  KEY `ix_file_uploaded_by` (`uploaded_by`),
  KEY `ix_file_status` (`status`),
  KEY `ix_file_uploaded_at` (`uploaded_at` DESC),
  CONSTRAINT `fk_file_uploader` FOREIGN KEY (`uploaded_by`) REFERENCES `users` (`id`),
  CONSTRAINT `fk_file_deleter` FOREIGN KEY (`deleted_by`) REFERENCES `users` (`id`) ON DELETE SET NULL,
  CONSTRAINT `chk_file_size_nonneg` CHECK (`file_size` >= 0)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='文件存储表：统一管理所有文件的元数据信息';
```

### 4.8 创建浮动成本/费用报销记录表 (`biz_expense_records`)

**设计**: 记录所有浮动成本（报销），包括销售浮动成本和执行浮动成本

**核心概念**:
- **销售浮动成本**: 如客户招待、路费（通常挂载在`客户`或`主订单`上）
- **执行浮动成本**: 如员工外出办事产生的费用（通常挂载在`具体的服务单/order_item`上）
- **文件关联**: 通过 `file_storage` 表关联报销凭证文件，一个报销单可以关联多个文件

**核心字段**:
- `expense_no`: 报销单号
- `applicant_id`: 申请人/报销员工ID
- `amount`: 报销金额
- `currency`: 币种 (CNY/IDR)
- `category`: 费用类别
- `cost_attribution`: 成本归属 (SALES/EXECUTION/OPERATION)
- `customer_id`: 关联客户（销售招待常用）
- `order_id`: 关联主订单（销售跟单费用）
- `order_item_id`: 关联具体服务项（执行/中台办事费用）
- `status`: 审批状态

**文件关联说明**:
- 报销凭证文件存储在 `file_storage` 表中
- 通过 `file_storage.business_type='EXPENSE'` 和 `file_storage.business_id=报销单ID` 关联
- 一个报销单可以关联多个文件（发票、收据、合同等）

```sql
DROP TABLE IF EXISTS `biz_expense_records`;

CREATE TABLE `biz_expense_records` (
  `id` CHAR(36) NOT NULL DEFAULT (UUID()),
  `expense_no` VARCHAR(50) NOT NULL COMMENT '报销单号 (如 EXP-20231027-001)',
  
  -- 1. 归属人与金额
  `applicant_id` CHAR(36) NOT NULL COMMENT '申请人/报销员工ID (关联 users.id)',
  `amount` DECIMAL(18,2) NOT NULL COMMENT '报销金额',
  `currency` VARCHAR(10) DEFAULT 'CNY' COMMENT '币种 (CNY/IDR)',
  `category` VARCHAR(50) NOT NULL COMMENT '费用类别 (如: 交通费, 餐饮招待, 签证费, 资料打印)',
  
  -- 2. 成本归集核心字段 (决定了这笔钱从谁的利润里扣)
  `cost_attribution` ENUM('SALES','EXECUTION','OPERATION') NOT NULL COMMENT '成本归属: SALES(销售成本), EXECUTION(执行成本), OPERATION(公司运营)',
  
  -- 3. 业务关联 (这笔钱是为谁花的?)
  `customer_id` CHAR(36) DEFAULT NULL COMMENT '关联客户 (销售招待常用)',
  `order_id` CHAR(36) DEFAULT NULL COMMENT '关联主订单 (销售跟单费用)',
  `order_item_id` CHAR(36) DEFAULT NULL COMMENT '关联具体服务项 (执行/中台办事费用)',
  
  -- 4. 审批与财务状态
  `status` ENUM('DRAFT','PENDING','APPROVED','REJECTED','PAID') DEFAULT 'DRAFT' COMMENT '状态: 草稿, 审批中, 已同意, 已驳回, 已打款',
  `audit_status_comment` VARCHAR(255) DEFAULT NULL COMMENT '审批/驳回意见',
  `approved_by` CHAR(36) DEFAULT NULL COMMENT '审批人ID',
  `approved_at` DATETIME DEFAULT NULL COMMENT '审批时间',
  `paid_at` DATETIME DEFAULT NULL COMMENT '财务打款时间(实际发生成本的时间)',
  
  -- 5. 备注说明
  `description` TEXT COMMENT '费用备注说明',
  
  `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  
  PRIMARY KEY (`id`),
  UNIQUE KEY `ux_expense_no` (`expense_no`),
  KEY `ix_expense_applicant` (`applicant_id`),
  KEY `ix_expense_order` (`order_id`),
  KEY `ix_expense_item` (`order_item_id`),
  KEY `ix_expense_customer` (`customer_id`),
  KEY `ix_expense_status` (`status`),
  KEY `ix_expense_attribution` (`cost_attribution`),
  CONSTRAINT `fk_exp_applicant` FOREIGN KEY (`applicant_id`) REFERENCES `users` (`id`),
  CONSTRAINT `fk_exp_customer` FOREIGN KEY (`customer_id`) REFERENCES `customers` (`id`),
  CONSTRAINT `fk_exp_order` FOREIGN KEY (`order_id`) REFERENCES `orders` (`id`),
  CONSTRAINT `fk_exp_order_item` FOREIGN KEY (`order_item_id`) REFERENCES `order_items` (`id`),
  CONSTRAINT `chk_expense_amount_nonneg` CHECK (`amount` >= 0)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='浮动成本/费用报销记录表';

-- 注意：报销凭证文件通过 file_storage 表关联
-- 查询报销单的文件：SELECT * FROM file_storage WHERE business_type='EXPENSE' AND business_id=报销单ID
```

**文件关联查询示例**:
```sql
-- 查询报销单及其所有凭证文件
SELECT 
  e.*,
  GROUP_CONCAT(
    CONCAT(
      fs.id, '|',
      fs.file_name, '|',
      fs.file_size, '|',
      fs.file_md5, '|',
      fs.oss_url, '|',
      fs.uploaded_at
    ) SEPARATOR '||'
  ) AS files_info
FROM biz_expense_records e
LEFT JOIN file_storage fs ON fs.business_type = 'EXPENSE' AND fs.business_id = e.id AND fs.status = 'ACTIVE'
WHERE e.id = ?
GROUP BY e.id;
```

---

## 五、业务逻辑与数据流向

### 5.1 场景一：销售报价查询（销售价格）

**业务场景**: 销售需要为客户（已知客户等级）查询服务的**销售价格**（对外售价）

**重要说明**:
- 这里查询的是**销售价格**（`product_price_list`），不是成本价格
- 销售价格根据客户等级分级设置，一个产品一条记录包含所有等级的价格
- 成本价格由内部团队或外部供应商在 `supplier_cost_history` 表中提供

**流程**:
1. **输入**: 客户ID（已知客户等级）、服务ID
2. **查询客户等级**: 
   ```sql
   SELECT level_code FROM customers WHERE id = ?
   ```
3. **查询销售价格**: 
   ```sql
   SELECT 
     CASE level_code
       WHEN '2' THEN price_level2_cny
       WHEN '3' THEN price_level3_cny
       WHEN '4' THEN price_level4_cny
       WHEN '5' THEN price_level5_cny
       WHEN '6' THEN price_level6_cny
       ELSE NULL
     END AS price_cny,
     CASE level_code
       WHEN '2' THEN price_level2_idr
       WHEN '3' THEN price_level3_idr
       WHEN '4' THEN price_level4_idr
       WHEN '5' THEN price_level5_idr
       WHEN '6' THEN price_level6_idr
       ELSE NULL
     END AS price_idr
   FROM product_price_list 
   WHERE product_id = ? 
     AND is_active = 1
     AND effective_from <= NOW()  -- 检查生效开始时间
     AND (effective_to IS NULL OR effective_to > NOW())  -- 检查生效结束时间
   ```
4. **返回**: 人民币销售价格和印尼盾销售价格

**API 设计**:
```
GET /api/v1/products/{product_id}/sales-price?customer_id={customer_id}
Response: {
  "product_id": "...",
  "product_name": "公司注册",
  "customer_id": "...",
  "level_code": "3",
  "level_name": "国有企业和上市公司",
  "sales_price_cny": 10000.00,  // 销售价格（对外售价）
  "sales_price_idr": 20000000.00,
  "currency": "CNY"  // 默认货币
}

GET /api/v1/products/{product_id}/sales-prices
Response: {
  "product_id": "...",
  "product_name": "公司注册",
  "sales_prices": {
    "level2": {
      "level_code": "2",
      "level_name": "央企总部和龙头企业",
      "price_cny": 50000.00,
      "price_idr": 100000000.00
    },
    "level3": {
      "level_code": "3",
      "level_name": "国有企业和上市公司",
      "price_cny": 30000.00,
      "price_idr": 60000000.00
    },
    "level4": {
      "level_code": "4",
      "level_name": "非上市品牌公司",
      "price_cny": 20000.00,
      "price_idr": 40000000.00
    },
    "level5": {
      "level_code": "5",
      "level_name": "中小型企业",
      "price_cny": 10000.00,
      "price_idr": 20000000.00
    },
    "level6": {
      "level_code": "6",
      "level_name": "个人创业小公司",
      "price_cny": 5000.00,
      "price_idr": 10000000.00
    }
  },
  "is_active": true,
  "effective_from": "2024-01-01T00:00:00Z"
}
```

### 5.2 场景二：中台 (KK) 派单与服务提供方选择（成本价格）

**业务场景**: 订单生成后，KK 需要为订单项选择执行服务提供方（内部团队或外部供应商），并查看各方的**成本价格**

**重要说明**:
- 这里查询的是**成本价格**（`supplier_cost_history`），不是销售价格
- 内部团队和外部供应商都提供成本价格，都需要版本控制
- 销售价格已经在订单创建时从 `product_price_list` 中获取

**流程**:
1. **查询可用服务提供方的成本价格（包括内部团队和外部供应商）**: 
   ```sql
   SELECT 
     sch.id AS cost_history_id,
     sch.supplier_id,
     sch.delivery_type,
     o.name AS provider_name,
     o.organization_type,
     sch.cost_cny AS cost_price_cny,  -- 成本价格（不是销售价格）
     sch.cost_idr AS cost_price_idr,
     sch.version,
     sch.notes,
     sch.effective_start_at
   FROM supplier_cost_history sch
   JOIN organizations o ON sch.supplier_id = o.id
   WHERE sch.product_id = ?
     AND sch.is_current = 1  -- 只查询当前有效的成本价格版本
     AND o.is_active = 1
     AND (
       o.organization_type = 'vendor' OR  -- 外部供应商
       o.organization_type = 'internal'   -- 内部团队
     )
   ORDER BY 
     sch.delivery_type ASC,  -- 先显示内部交付，再显示供应商交付
     sch.cost_cny ASC        -- 按成本价格排序
   ```
2. **决策**: KK 根据以下因素选择服务提供方：
   - **成本价格**: 内部交付成本价格 vs 供应商成本价格
   - **速度**: 内部团队的执行速度 vs 供应商的执行速度
   - **质量**: 内部团队的专业度 vs 供应商的专业度
   - **利润**: 利润 = 销售价格 - 成本价格，选择利润更高的方案
   - **执行周期长度**: 内部团队的执行周期 vs 供应商的执行周期
3. **更新订单项**:
   ```sql
   UPDATE order_items 
   SET 
     selected_supplier_id = ?,
     delivery_type = ?,  -- 'INTERNAL' 或 'VENDOR'
     supplier_cost_history_id = ?,  -- 关联到具体的成本价格版本
     snapshot_cost_cny = ?,  -- 成本价格快照（用于利润核算）
     snapshot_cost_idr = ?,
     estimated_profit_cny = unit_price - ?,  -- 预估利润 = 销售价格 - 成本价格
     estimated_profit_idr = (unit_price * exchange_rate) - ?
   WHERE id = ?
   ```

**API 设计**:
```
GET /api/v1/products/{product_id}/cost-prices
Response: {
  "product_id": "...",
  "product_name": "公司注册",
  "cost_prices": [  // 成本价格列表（不是销售价格）
    {
      "cost_history_id": "...",
      "provider_id": "...",
      "provider_name": "企业服务组",
      "delivery_type": "INTERNAL",
      "organization_type": "internal",
      "cost_price_cny": 1500.00,  // 成本价格
      "cost_price_idr": 3000000.00,
      "version": 1,
      "is_current": true,
      "effective_from": "2024-01-01T00:00:00Z",
      "notes": "内部团队人力成本"
    },
    {
      "cost_history_id": "...",
      "provider_id": "...",
      "provider_name": "供应商A",
      "delivery_type": "VENDOR",
      "organization_type": "vendor",
      "cost_price_cny": 2000.00,  // 成本价格
      "cost_price_idr": 4000000.00,
      "version": 1,
      "is_current": true,
      "effective_from": "2024-01-01T00:00:00Z",
      "notes": "供应商报价"
    },
    ...
  ]
}

POST /api/v1/order-items/{order_item_id}/assign-provider
Request: {
  "provider_id": "...",
  "delivery_type": "INTERNAL",  // 或 "VENDOR"
  "supplier_cost_history_id": "..."  // 关联到具体的成本价格版本ID
}
```

**业务说明**:
- **内部交付优势**: 
  - 利润留在公司内部
  - 更好的质量控制
  - 更快的响应速度
  - 更好的客户关系维护
- **供应商交付优势**:
  - 可能成本更低（供应商规模效应）
  - 专业度可能更高（供应商专注特定领域）
  - 减少内部团队工作负荷

### 5.3 场景三：服务提供方成本价格更新（内部团队或供应商）

**业务场景**: 内部团队成本价格调整或供应商通知我们下个月涨价（更新成本价格，不是销售价格）

**重要说明**:
- 这里更新的是**成本价格**（`supplier_cost_history`），不是销售价格
- 内部团队和外部供应商的成本价格都需要版本控制
- 销售价格在 `product_price_list` 表中单独管理

**流程**:
1. **查询当前成本价格**:
   ```sql
   SELECT * FROM supplier_cost_history 
   WHERE product_id = ? 
     AND supplier_id = ? 
     AND is_current = 1
   ```
2. **关闭旧成本价格版本**:
   ```sql
   UPDATE supplier_cost_history 
   SET 
     effective_end_at = NOW(),
     is_current = 0
   WHERE id = ?
   ```
3. **创建新成本价格版本**（使用事务保证版本号正确）:
   ```sql
   BEGIN;
   
   -- 关闭所有旧版本（不仅仅是当前版本，防止时间段重叠）
   UPDATE supplier_cost_history 
   SET 
     effective_end_at = NOW(),
     is_current = 0
   WHERE product_id = ? 
     AND supplier_id = ? 
     AND (effective_end_at IS NULL OR effective_end_at > NOW());
   
   -- 查询最大版本号（加锁防止并发）
   SELECT COALESCE(MAX(version), 0) INTO @max_version 
   FROM supplier_cost_history 
   WHERE product_id = ? AND supplier_id = ? 
   FOR UPDATE;
   
   SET @new_version = @max_version + 1;
   
   -- 创建新版本
   INSERT INTO supplier_cost_history (
     product_id, supplier_id, delivery_type, version, 
     cost_cny, cost_idr,
     effective_start_at, is_current, created_by, notes
   ) VALUES (
     ?, ?, ?, @new_version,
     ?, ?, NOW(), 1, ?, ?
   );
   
   COMMIT;
   ```
4. **影响分析**:
   - **新订单**: 自动关联到新成本价格版本
   - **旧订单**: `order_items.supplier_cost_history_id` 仍指向旧成本价格版本，利润核算不受影响

**API 设计**:
```
POST /api/v1/providers/{provider_id}/products/{product_id}/cost-price
Request: {
  "delivery_type": "VENDOR",  // 或 "INTERNAL"
  "cost_price_cny": 2500.00,  // 成本价格（不是销售价格）
  "cost_price_idr": 5000000.00,
  "effective_from": "2025-01-01T00:00:00Z",
  "notes": "下个月涨价"  // 或 "内部人力成本调整"
}

Response: {
  "id": "...",
  "product_id": "...",
  "provider_id": "...",
  "delivery_type": "VENDOR",
  "version": 2,
  "cost_price_cny": 2500.00,
  "cost_price_idr": 5000000.00,
  "effective_start_at": "2025-01-01T00:00:00Z",
  "is_current": true
}
```

**业务说明**:
- **内部团队成本价格更新**: 可能是人力成本调整、效率提升导致成本降低等
- **供应商成本价格更新**: 供应商主动涨价/降价，或我们重新谈判价格
- **版本控制**: 所有成本价格变更都记录历史版本，确保历史订单的成本价格不变
- **与销售价格的关系**: 成本价格和销售价格是独立的，成本价格更新不影响销售价格

### 5.4 场景四：订单创建时的价格和成本快照

**业务场景**: 销售创建订单，系统自动记录价格和成本快照

**流程**:
1. **创建订单项时**:
   - 根据客户等级查询销售价格（`product_price_list`）
   - 设置订单项的 `unit_price` 和 `currency_code`
2. **KK 分配供应商后**:
   - 根据选择的供应商，查询当前成本（`supplier_cost_history`）
   - 更新订单项的成本快照字段
   - 计算预估利润

**代码示例**:
```python
async def create_order_item(order_id: str, product_id: str, customer_id: str):
    # 1. 查询客户等级
    customer = await get_customer(customer_id)
    level_code = customer.level_code
    
    # 2. 查询销售价格
    price = await get_product_price(product_id, level_code)
    
    # 3. 创建订单项（此时供应商未分配）
    order_item = OrderItem(
        order_id=order_id,
        product_id=product_id,
        unit_price=price.price_cny,
        currency_code='CNY',
        # selected_supplier_id = NULL (待分配)
    )
    
    # 4. KK 分配服务提供方后（内部团队或外部供应商）
    provider_cost = await get_current_provider_cost(product_id, provider_id)
    order_item.selected_supplier_id = provider_id
    order_item.delivery_type = provider_cost.delivery_type  # 'INTERNAL' 或 'VENDOR'
    order_item.supplier_cost_history_id = provider_cost.id
    order_item.snapshot_cost_cny = provider_cost.cost_cny
    order_item.snapshot_cost_idr = provider_cost.cost_idr
    order_item.estimated_profit_cny = price.price_cny - provider_cost.cost_cny
    order_item.estimated_profit_idr = price.price_idr - provider_cost.cost_idr
```

### 5.5 场景五：订单阶段初始化与进度预警

**业务场景**: 订单项创建后，根据服务模板自动创建执行阶段，并定时检查进度预警

#### 5.5.1 订单阶段初始化流程

**触发时机**: 订单项创建且供应商已分配后

**流程**:
1. **查询服务阶段模板**:
   ```sql
   SELECT * FROM service_stage_templates 
   WHERE product_id = ? 
   ORDER BY stage_order ASC
   ```
2. **为每个阶段创建订单阶段记录**:
   ```python
   async def initialize_order_stages(order_item_id: str, product_id: str):
       # 1. 查询阶段模板
       templates = await get_stage_templates(product_id)
       
       # 2. 获取订单项信息
       order_item = await get_order_item(order_item_id)
       order = await get_order(order_item.order_id)
       
       # 3. 计算起始日期（从订单创建日期或预期开始日期开始）
       start_date = order_item.expected_start_date or order.created_at.date()
       current_date = start_date
       
       # 4. 为每个阶段创建记录
       for template in templates:
           expected_start = current_date
           expected_end = current_date + timedelta(days=template.standard_days)
           
           stage = OrderStage(
               order_id=order_item.order_id,
               order_item_id=order_item_id,  # 关键：关联到订单项
               stage_name=template.stage_name_zh,
               stage_code=f"stage_{template.stage_order}",
               stage_order=template.stage_order,
               stage_template_id=template.id,
               expected_start_date=expected_start,
               expected_end_date=expected_end,
               status='pending',
               alert_level='normal'
           )
           await create_order_stage(stage)
           
           # 下一个阶段从当前阶段结束日期开始
           current_date = expected_end + timedelta(days=1)
       
       # 5. 更新订单项的预期完成日期
       order_item.expected_completion_date = current_date - timedelta(days=1)
   ```

#### 5.5.2 进度预警机制

**定时任务**: 每小时或每天执行一次

**流程**:
1. **查询即将超期或已超期的阶段**:
   ```sql
   SELECT 
     os.*,
     oi.product_id,
     oi.product_name_zh,
     o.order_number,
     o.customer_id,
     c.name AS customer_name
   FROM order_stages os
   JOIN order_items oi ON os.order_item_id = oi.id
   JOIN orders o ON oi.order_id = o.id
   JOIN customers c ON o.customer_id = c.id
   WHERE os.status != 'completed'
     AND os.expected_end_date IS NOT NULL
     AND (
       -- 即将超期（3天内）
       (os.expected_end_date BETWEEN CURDATE() AND DATE_ADD(CURDATE(), INTERVAL 3 DAY))
       OR
       -- 已超期
       (os.expected_end_date < CURDATE())
     )
     AND os.is_overdue = 0
   ```
2. **更新预警状态**:
   ```sql
   UPDATE order_stages 
   SET 
     is_overdue = CASE 
       WHEN expected_end_date < CURDATE() THEN 1 
       ELSE 0 
     END,
     alert_level = CASE 
       WHEN expected_end_date < CURDATE() THEN 'critical'
       WHEN DATEDIFF(expected_end_date, CURDATE()) <= 1 THEN 'critical'
       WHEN DATEDIFF(expected_end_date, CURDATE()) <= 3 THEN 'warning'
       ELSE 'normal'
     END
   WHERE id IN (...)
   ```
3. **发送通知**: 
   - 通知订单项负责人（`order_stages.assigned_to_user_id`）
   - 通知订单销售（`orders.sales_user_id`）
   - 通知中台负责人（KK）

**API 设计**:
```
GET /api/v1/order-stages/overdue?alert_level=critical
Response: {
  "overdue_stages": [
    {
      "order_id": "...",
      "order_item_id": "...",
      "stage_name": "资料收集",
      "expected_end_date": "2024-12-10",
      "overdue_days": 3,
      "alert_level": "critical"
    },
    ...
  ]
}
```

---

## 六、利润核算逻辑

### 6.1 订单级利润核算

**公式**:
```
订单毛利 = 订单收入 - 服务提供方成本（内部成本+供应商成本）- 销售浮动成本 - 执行浮动成本
```

**说明**:
- **服务提供方成本**: 包括内部交付成本（内部团队人力成本）和供应商交付成本（供应商报价）
- **统一核算**: 无论是内部交付还是供应商交付，成本都统一在 `order_items.snapshot_cost_cny` 中记录

**SQL 查询**:
```sql
SELECT 
    o.id AS order_id,
    o.order_number,
    o.total_amount AS order_revenue,
    
    -- 服务提供方成本（从订单项汇总，包括内部成本和供应商成本）
    (SELECT IFNULL(SUM(snapshot_cost_cny), 0) 
     FROM order_items 
     WHERE order_id = o.id) AS provider_cost,
    
    -- 内部交付成本（明细）
    (SELECT IFNULL(SUM(snapshot_cost_cny), 0) 
     FROM order_items 
     WHERE order_id = o.id 
       AND delivery_type = 'INTERNAL') AS internal_cost,
    
    -- 供应商交付成本（明细）
    (SELECT IFNULL(SUM(snapshot_cost_cny), 0) 
     FROM order_items 
     WHERE order_id = o.id 
       AND delivery_type = 'VENDOR') AS vendor_cost,
    
    -- 销售浮动成本（报销，归属 SALES）
    (SELECT IFNULL(SUM(amount), 0) 
     FROM biz_expense_records 
     WHERE order_id = o.id 
       AND cost_attribution = 'SALES' 
       AND status = 'PAID') AS sales_floating_cost,
    
    -- 执行浮动成本（报销，归属 EXECUTION）
    (SELECT IFNULL(SUM(amount), 0) 
     FROM biz_expense_records 
     WHERE order_item_id IN (
       SELECT id FROM order_items WHERE order_id = o.id
     ) 
     AND cost_attribution = 'EXECUTION' 
     AND status = 'PAID') AS execution_floating_cost,
    
    -- 最终毛利
    (o.total_amount 
     - (SELECT IFNULL(SUM(snapshot_cost_cny), 0) FROM order_items WHERE order_id = o.id)
     - (SELECT IFNULL(SUM(amount), 0) FROM biz_expense_records WHERE order_id = o.id AND cost_attribution = 'SALES' AND status = 'PAID')
     - (SELECT IFNULL(SUM(amount), 0) FROM biz_expense_records WHERE order_item_id IN (SELECT id FROM order_items WHERE order_id = o.id) AND cost_attribution = 'EXECUTION' AND status = 'PAID')
    ) AS net_profit
    
FROM orders o
WHERE o.id = ?;
```

### 6.2 订单项级利润核算

**公式**:
```
订单项毛利 = 订单项收入 - 服务提供方成本（内部成本或供应商成本）- 执行浮动成本（关联到此订单项的报销）
```

**SQL 查询**:
```sql
SELECT 
    oi.id AS order_item_id,
    oi.product_name_zh,
    oi.delivery_type,
    oi.unit_price * oi.quantity AS item_revenue,
    oi.snapshot_cost_cny AS provider_cost,
    oi.estimated_profit_cny AS estimated_profit,
    
    -- 服务提供方信息
    o.name AS provider_name,
    o.organization_type,
    
    -- 执行浮动成本（关联到此订单项的报销）
    (SELECT IFNULL(SUM(amount), 0) 
     FROM biz_expense_records 
     WHERE order_item_id = oi.id 
       AND cost_attribution = 'EXECUTION' 
       AND status = 'PAID') AS execution_floating_cost,
    
    -- 实际利润
    (oi.unit_price * oi.quantity 
     - oi.snapshot_cost_cny
     - (SELECT IFNULL(SUM(amount), 0) FROM biz_expense_records WHERE order_item_id = oi.id AND cost_attribution = 'EXECUTION' AND status = 'PAID')
    ) AS actual_profit
    
FROM order_items oi
WHERE oi.id = ?;
```

---

## 七、数据迁移方案

### 7.1 历史价格数据迁移

**目标**: 将 `products` 表中的旧价格字段迁移到 `product_price_list` 表

**步骤**:
1. **识别需要迁移的产品**:
   ```sql
   SELECT id, code, name, 
          price_direct_cny, price_direct_idr,
          price_channel_cny, price_channel_idr
   FROM products 
   WHERE price_direct_cny IS NOT NULL 
      OR price_channel_cny IS NOT NULL
   ```
2. **为每个产品创建价格记录**（一条记录包含所有等级的价格）:
   ```sql
   INSERT INTO product_price_list (
     product_id, 
     price_level2_cny, price_level2_idr,
     price_level3_cny, price_level3_idr,
     price_level4_cny, price_level4_idr,
     price_level5_cny, price_level5_idr,
     price_level6_cny, price_level6_idr
   )
   SELECT 
     id AS product_id,
     -- 等级2：使用直客价格或渠道价格（根据业务规则）
     COALESCE(price_direct_cny, price_channel_cny, 0) AS price_level2_cny,
     COALESCE(price_direct_idr, price_channel_idr, 0) AS price_level2_idr,
     -- 等级3-6：可以根据业务规则设置不同的价格，这里先用相同价格
     COALESCE(price_direct_cny, price_channel_cny, 0) AS price_level3_cny,
     COALESCE(price_direct_idr, price_channel_idr, 0) AS price_level3_idr,
     COALESCE(price_channel_cny, price_direct_cny, 0) AS price_level4_cny,
     COALESCE(price_channel_idr, price_direct_idr, 0) AS price_level4_idr,
     COALESCE(price_channel_cny, price_direct_cny, 0) AS price_level5_cny,
     COALESCE(price_channel_idr, price_direct_idr, 0) AS price_level5_idr,
     COALESCE(price_channel_cny, price_direct_cny, 0) AS price_level6_cny,
     COALESCE(price_channel_idr, price_direct_idr, 0) AS price_level6_idr
   FROM products
   WHERE price_direct_cny IS NOT NULL OR price_channel_cny IS NOT NULL;
   ```
3. **验证数据**:
   ```sql
   SELECT COUNT(*) FROM product_price_list;
   SELECT * FROM product_price_list LIMIT 10;
   ```

### 7.2 历史服务提供方成本迁移

**目标**: 将 `products.vendor_id` 和 `products.price_cost_cny` 迁移到 `supplier_cost_history` 表

**步骤**:
1. **识别需要迁移的产品**:
   ```sql
   SELECT p.id, p.vendor_id, p.price_cost_cny, p.price_cost_idr, o.organization_type
   FROM products p
   LEFT JOIN organizations o ON p.vendor_id = o.id
   WHERE p.vendor_id IS NOT NULL 
     AND (p.price_cost_cny IS NOT NULL OR p.price_cost_idr IS NOT NULL)
   ```
2. **创建服务提供方成本历史记录**:
   ```sql
   INSERT INTO supplier_cost_history (
     product_id, supplier_id, delivery_type, version,
     cost_cny, cost_idr,
     effective_start_at, is_current
   )
   SELECT 
     p.id AS product_id,
     p.vendor_id AS supplier_id,
     CASE 
       WHEN o.organization_type = 'internal' THEN 'INTERNAL'
       WHEN o.organization_type = 'vendor' THEN 'VENDOR'
       ELSE 'VENDOR'  -- 默认值
     END AS delivery_type,
     1 AS version,
     COALESCE(p.price_cost_cny, 0) AS cost_cny,
     COALESCE(p.price_cost_idr, 0) AS cost_idr,
     p.created_at AS effective_start_at,
     1 AS is_current
   FROM products p
   JOIN organizations o ON p.vendor_id = o.id
   WHERE p.vendor_id IS NOT NULL 
     AND (p.price_cost_cny IS NOT NULL OR p.price_cost_idr IS NOT NULL)
     AND o.organization_type IN ('internal', 'vendor');
   ```

### 7.3 订单项服务提供方关联迁移

**目标**: 为已有订单项补充服务提供方信息（如果产品有默认服务提供方）

**步骤**:
```sql
UPDATE order_items oi
JOIN products p ON oi.product_id = p.id
JOIN organizations o ON p.vendor_id = o.id
SET 
  oi.selected_supplier_id = p.vendor_id,
  oi.delivery_type = CASE 
    WHEN o.organization_type = 'internal' THEN 'INTERNAL'
    WHEN o.organization_type = 'vendor' THEN 'VENDOR'
    ELSE 'VENDOR'
  END,
  oi.supplier_cost_history_id = (
    SELECT id FROM supplier_cost_history 
    WHERE product_id = p.id 
      AND supplier_id = p.vendor_id 
      AND is_current = 1 
    LIMIT 1
  ),
  oi.snapshot_cost_cny = COALESCE(p.price_cost_cny, 0),
  oi.snapshot_cost_idr = COALESCE(p.price_cost_idr, 0)
WHERE oi.selected_supplier_id IS NULL
  AND p.vendor_id IS NOT NULL;
```

---

## 八、API 设计要点

### 8.1 产品销售价格查询 API（对外售价）

**注意**: 这是查询**销售价格**（对外售价），不是成本价格。成本价格在 8.2 节中查询。

**设计说明**: 一个产品一条记录包含所有等级的价格，简化维护。

```
GET /api/v1/products/{product_id}/sales-price?customer_id={customer_id}
Query Parameters:
  - customer_id: 客户ID（必需，用于获取客户等级）

Response: {
  "product_id": "...",
  "product_name": "公司注册",
  "customer_id": "...",
  "level_code": "3",
  "level_name": "国有企业和上市公司",
  "sales_price_cny": 30000.00,  // 销售价格（对外售价）
  "sales_price_idr": 60000000.00,
  "currency": "CNY"
}

GET /api/v1/products/{product_id}/sales-prices
Response: {
  "product_id": "...",
  "product_name": "公司注册",
  "sales_prices": {  // 所有等级的价格（一条记录）
    "level2": {
      "level_code": "2",
      "level_name": "央企总部和龙头企业",
      "price_cny": 50000.00,
      "price_idr": 100000000.00
    },
    "level3": {
      "level_code": "3",
      "level_name": "国有企业和上市公司",
      "price_cny": 30000.00,
      "price_idr": 60000000.00
    },
    "level4": {
      "level_code": "4",
      "level_name": "非上市品牌公司",
      "price_cny": 20000.00,
      "price_idr": 40000000.00
    },
    "level5": {
      "level_code": "5",
      "level_name": "中小型企业",
      "price_cny": 10000.00,
      "price_idr": 20000000.00
    },
    "level6": {
      "level_code": "6",
      "level_name": "个人创业小公司",
      "price_cny": 5000.00,
      "price_idr": 10000000.00
    }
  },
  "is_active": true,
  "effective_from": "2024-01-01T00:00:00Z",
  "effective_to": null
}

POST /api/v1/products/{product_id}/sales-prices
Request: {
  "price_level2_cny": 50000.00,
  "price_level2_idr": 100000000.00,
  "price_level3_cny": 30000.00,
  "price_level3_idr": 60000000.00,
  "price_level4_cny": 20000.00,
  "price_level4_idr": 40000000.00,
  "price_level5_cny": 10000.00,
  "price_level5_idr": 20000000.00,
  "price_level6_cny": 5000.00,
  "price_level6_idr": 10000000.00,
  "effective_from": "2024-01-01T00:00:00Z"
}
```

### 8.2 服务提供方成本管理 API

```
GET /api/v1/products/{product_id}/providers/costs
Query Parameters:
  - delivery_type: INTERNAL | VENDOR（可选，过滤交付类型）
  - include_history: true | false（可选，是否包含历史版本，默认false）

Response: {
  "product_id": "...",
  "product_name": "公司注册",
  "providers": [
    {
      "provider_id": "...",
      "provider_name": "企业服务组",
      "delivery_type": "INTERNAL",
      "organization_type": "internal",
      "current_cost": {
        "id": "...",
        "cost_cny": 1500.00,
        "cost_idr": 3000000.00,
        "version": 1,
        "effective_from": "2024-01-01T00:00:00Z",
        "notes": "内部人力成本"
      },
      "history": [
        {
          "version": 1,
          "cost_cny": 1500.00,
          "effective_from": "2024-01-01T00:00:00Z",
          "effective_to": null
        }
      ]
    },
    {
      "provider_id": "...",
      "provider_name": "供应商A",
      "delivery_type": "VENDOR",
      "organization_type": "vendor",
      "current_cost": {
        "id": "...",
        "cost_cny": 2000.00,
        "cost_idr": 4000000.00,
        "version": 2,
        "effective_from": "2024-12-01T00:00:00Z",
        "notes": "供应商报价"
      },
      "history": [
        {
          "version": 1,
          "cost_cny": 1800.00,
          "effective_from": "2024-01-01T00:00:00Z",
          "effective_to": "2024-11-30T23:59:59Z"
        },
        {
          "version": 2,
          "cost_cny": 2000.00,
          "effective_from": "2024-12-01T00:00:00Z",
          "effective_to": null
        }
      ]
    }
  ]
}

POST /api/v1/providers/{provider_id}/products/{product_id}/cost-price
Request: {
  "delivery_type": "VENDOR",  // 或 "INTERNAL"
  "cost_price_cny": 2500.00,  // 成本价格（不是销售价格）
  "cost_price_idr": 5000000.00,
  "effective_from": "2025-01-01T00:00:00Z",
  "notes": "下个月涨价"  // 或 "内部人力成本调整"
}

Response: {
  "id": "...",
  "product_id": "...",
  "provider_id": "...",
  "delivery_type": "VENDOR",
  "version": 3,
  "cost_price_cny": 2500.00,  // 成本价格
  "cost_price_idr": 5000000.00,
  "effective_start_at": "2025-01-01T00:00:00Z",
  "is_current": true,
  "notes": "下个月涨价"
}
```

**价格体系总结**:
- **销售价格** (`product_price_list`): 对外销售价格，一个产品一条记录包含所有等级的价格（简化维护），通过 `is_active` 和 `effective_from/effective_to` 控制生效时间
- **成本价格** (`supplier_cost_history`): 内部团队或外部供应商的成本价格，需要版本控制，价格变更不影响历史订单

### 8.3 文件管理 API

**重要说明**:
- 文件实际存储在OSS，数据库中存储完整的文件元数据
- 支持多种业务类型：报销凭证、合同、订单文件等
- 文件元数据包含：文件名、大小、MD5、创建时间、OSS地址等

```
POST /api/v1/files/upload
Request: FormData {
  "file": File,  // 单个文件
  "business_type": "EXPENSE",  // 业务类型: EXPENSE, CONTRACT, ORDER等
  "business_id": "...",  // 业务对象ID（可选，可以先上传后关联）
  "description": "发票文件",
  "tags": ["发票", "2024年12月"]  // 可选标签
}

Response: {
  "id": "...",
  "file_name": "invoice_20241213.jpg",
  "file_type": "EXPENSE_PROOF",
  "file_size": 245678,  // 字节
  "file_md5": "d41d8cd98f00b204e9800998ecf8427e",
  "mime_type": "image/jpeg",
  "file_extension": "jpg",
  "oss_bucket": "bantuqifu-dev",
  "oss_key": "expenses/2024/12/EXP-20241213-001_invoice_1.jpg",
  "oss_url": "https://bantuqifu-dev.oss-ap-southeast-5.aliyuncs.com/expenses/2024/12/EXP-20241213-001_invoice_1.jpg",
  "business_type": "EXPENSE",
  "business_id": "...",
  "uploaded_by": "...",
  "uploaded_at": "2024-12-13T10:00:00Z",
  "created_at": "2024-12-13T10:00:00Z"
}

POST /api/v1/files/batch-upload
Request: FormData {
  "files": [File, File, ...],  // 多个文件
  "business_type": "EXPENSE",
  "business_id": "...",
  "description": "报销凭证文件"
}

Response: {
  "uploaded_count": 3,
  "files": [
    {
      "id": "...",
      "file_name": "invoice_20241213.jpg",
      "file_size": 245678,
      "file_md5": "d41d8cd98f00b204e9800998ecf8427e",
      "oss_url": "...",
      "uploaded_at": "2024-12-13T10:00:00Z"
    },
    ...
  ]
}

GET /api/v1/files/{file_id}
Response: {
  "id": "...",
  "file_name": "invoice_20241213.jpg",
  "file_type": "EXPENSE_PROOF",
  "file_size": 245678,
  "file_md5": "d41d8cd98f00b204e9800998ecf8427e",
  "mime_type": "image/jpeg",
  "file_extension": "jpg",
  "oss_bucket": "bantuqifu-dev",
  "oss_key": "expenses/2024/12/EXP-20241213-001_invoice_1.jpg",
  "oss_url": "https://bantuqifu-dev.oss-ap-southeast-5.aliyuncs.com/expenses/2024/12/EXP-20241213-001_invoice_1.jpg",
  "business_type": "EXPENSE",
  "business_id": "...",
  "description": "发票文件",
  "tags": ["发票", "2024年12月"],
  "uploaded_by": "...",
  "uploaded_by_name": "张三",
  "uploaded_at": "2024-12-13T10:00:00Z",
  "created_at": "2024-12-13T10:00:00Z",
  "status": "ACTIVE"
}

GET /api/v1/files?business_type=EXPENSE&business_id={expense_id}
Response: {
  "business_type": "EXPENSE",
  "business_id": "...",
  "total": 3,
  "files": [
    {
      "id": "...",
      "file_name": "invoice_20241213.jpg",
      "file_size": 245678,
      "file_md5": "d41d8cd98f00b204e9800998ecf8427e",
      "mime_type": "image/jpeg",
      "oss_url": "...",
      "uploaded_at": "2024-12-13T10:00:00Z",
      "uploaded_by_name": "张三"
    },
    ...
  ]
}

DELETE /api/v1/files/{file_id}
Response: {
  "id": "...",
  "status": "DELETED",
  "deleted_at": "2024-12-13T11:00:00Z"
}
```

### 8.4 费用报销管理 API

**重要说明**:
- 报销凭证文件通过 `file_storage` 表关联
- 查询报销单时，同时返回关联的所有文件信息（包含完整元数据）

```
POST /api/v1/expenses
Request: {
  "applicant_id": "...",
  "amount": 500.00,
  "currency": "CNY",
  "category": "交通费",
  "cost_attribution": "EXECUTION",
  "order_item_id": "...",
  "description": "去移民局办理签证的路费"
}

Response: {
  "id": "...",
  "expense_no": "EXP-20241213-001",
  "applicant_id": "...",
  "amount": 500.00,
  "currency": "CNY",
  "category": "交通费",
  "cost_attribution": "EXECUTION",
  "order_item_id": "...",
  "status": "DRAFT",
  "description": "去移民局办理签证的路费",
  "files": [],  // 初始为空，上传文件后关联
  "created_at": "2024-12-13T10:00:00Z"
}

GET /api/v1/expenses/{expense_id}
Response: {
  "id": "...",
  "expense_no": "EXP-20241213-001",
  "applicant_id": "...",
  "applicant_name": "张三",
  "amount": 500.00,
  "currency": "CNY",
  "category": "交通费",
  "cost_attribution": "EXECUTION",
  "order_item_id": "...",
  "order_item_name": "公司注册",
  "status": "PENDING",
  "description": "去移民局办理签证的路费",
  "files": [  // 关联的文件列表（包含完整元数据）
    {
      "id": "...",
      "file_name": "invoice_20241213.jpg",
      "file_type": "EXPENSE_PROOF",
      "file_size": 245678,
      "file_md5": "d41d8cd98f00b204e9800998ecf8427e",
      "mime_type": "image/jpeg",
      "oss_url": "https://...",
      "uploaded_at": "2024-12-13T10:05:00Z",
      "uploaded_by_name": "张三"
    },
    {
      "id": "...",
      "file_name": "receipt_20241213.pdf",
      "file_type": "EXPENSE_PROOF",
      "file_size": 156789,
      "file_md5": "e4d909c290d0fb1ca068ffaddf22cbd0",
      "mime_type": "application/pdf",
      "oss_url": "https://...",
      "uploaded_at": "2024-12-13T10:06:00Z",
      "uploaded_by_name": "张三"
    }
  ],
  "created_at": "2024-12-13T10:00:00Z"
}

POST /api/v1/expenses/{expense_id}/files
Request: FormData {
  "files": [File, File, ...]  // 多个文件
}

Response: {
  "expense_id": "...",
  "uploaded_files": [
    {
      "id": "...",
      "file_name": "invoice_20241213.jpg",
      "file_size": 245678,
      "file_md5": "d41d8cd98f00b204e9800998ecf8427e",
      "oss_url": "...",
      "uploaded_at": "2024-12-13T10:05:00Z"
    },
    ...
  ]
}
```

### 8.4 服务阶段模板管理 API

```
GET /api/v1/products/{product_id}/stage-templates
Response: {
  "product_id": "...",
  "total_duration_days": 7,
  "stages": [
    {
      "id": "...",
      "stage_name_zh": "资料收集",
      "stage_name_id": "Pengumpulan Dokumen",
      "stage_order": 1,
      "standard_days": 2,
      "is_milestone": false
    },
    {
      "id": "...",
      "stage_name_zh": "任务执行",
      "stage_name_id": "Pelaksanaan Tugas",
      "stage_order": 2,
      "standard_days": 4,
      "is_milestone": true
    },
    ...
  ]
}

POST /api/v1/products/{product_id}/stage-templates
Request: {
  "stages": [
    {
      "stage_name_zh": "资料收集",
      "stage_name_id": "Pengumpulan Dokumen",
      "stage_order": 1,
      "standard_days": 2
    },
    ...
  ]
}
```

---

## 九、实施计划

### 9.1 第一阶段：数据库 Schema 更新（1-2天）

- [ ] 修改 `products` 表（添加标准执行时长字段）
- [ ] 创建 `product_price_list` 表
- [ ] 创建 `supplier_cost_history` 表
- [ ] 创建 `service_stage_templates` 表
- [ ] 创建 `file_storage` 表（文件存储表，统一管理所有文件元数据）
- [ ] 创建 `biz_expense_records` 表（浮动成本/费用报销记录表）
- [ ] 修改 `order_items` 表（添加供应商和成本字段）
- [ ] 修改 `order_stages` 表（添加进度预警字段）

### 9.2 第二阶段：数据迁移（1天）

- [ ] 迁移历史价格数据到 `product_price_list`
- [ ] 迁移历史供应商成本到 `supplier_cost_history`
- [ ] 为已有订单项补充供应商信息
- [ ] 数据验证和修复

### 9.3 第三阶段：业务逻辑实现（3-5天）

- [ ] 实现产品价格查询逻辑
- [ ] 实现供应商成本版本管理逻辑
- [ ] 实现订单创建时的价格和成本快照逻辑
- [ ] 实现服务阶段模板管理逻辑
- [ ] 实现进度预警逻辑

### 9.4 第四阶段：API 开发（2-3天）

- [ ] 产品价格查询 API
- [ ] 供应商成本管理 API
- [ ] 服务阶段模板管理 API
- [ ] 订单供应商分配 API
- [ ] 进度预警查询 API

### 9.5 第五阶段：测试和优化（2天）

- [ ] 单元测试
- [ ] 集成测试
- [ ] 性能优化
- [ ] 文档完善

**预计总工作量**: 9-13天

---

## 十、注意事项

### 10.1 数据一致性

1. **价格唯一性**: 确保同一产品在同一客户等级下只有一个有效价格
2. **成本版本连续性**: 确保供应商成本版本的时间段连续且不重叠
3. **订单成本快照**: 订单创建后，成本快照不应再变更

### 10.2 性能优化

1. **索引优化**: 在常用查询字段上创建索引
2. **查询优化**: 使用 JOIN 替代子查询（如果可能）
3. **缓存策略**: 价格和成本信息可以缓存，定期更新

### 10.3 向后兼容

1. **旧价格字段**: 保留但不使用，等待数据迁移完成后删除
2. **API 版本**: 新 API 使用 `/api/v1/` 前缀，旧 API 保持兼容
3. **数据迁移**: 提供回滚方案，确保可以回退

### 10.4 扩展性考虑

1. **多币种支持**: 当前支持 CNY 和 IDR，未来可扩展支持 USD、EUR 等
2. **价格策略**: 未来可支持更复杂的价格策略（如：阶梯价格、促销价格）
3. **供应商评级**: 未来可添加供应商评级和选择算法

---

## 十一、待确认事项

### 11.1 业务规则确认

- [x] 价格生效时间的最小粒度是多少？（小时、天、周） - **已确认：按天**
- [x] 供应商成本版本是否可以回退到历史版本？ - **已确认：可以，通过创建新版本实现**
- [x] 订单创建后，如果供应商报价变更，是否允许重新分配供应商？ - **已确认：允许，但需要重新计算成本快照**
- [x] 服务阶段模板是否可以自定义？还是只能使用系统预设？ - **已确认：可以自定义，每个服务可以设置自己的阶段模板**

### 11.2 技术方案确认

- [x] 价格和成本数据是否需要实时同步？还是可以异步更新？ - **已确认：实时同步**
- [x] 进度预警的检查频率是多少？（每小时、每天） - **已确认：每小时检查一次**
- [x] 是否需要支持价格审批流程？ - **已确认：暂不需要，直接生效**
- [x] 是否需要支持供应商报价的批量导入？ - **已确认：需要，支持Excel批量导入**
- [x] 报销凭证文件存储方式？ - **已确认：使用OSS存储，数据库中存储OSS地址字符串，支持多个文件**

---

---

## 十二、内部交付与供应商交付对比

### 12.1 内部交付特点

**适用场景**:
- 公司内部团队有专业能力提供服务
- 需要更好的质量控制和客户关系维护
- 希望利润留在公司内部
- 需要快速响应和灵活调整

**成本构成**:
- 人力成本（员工工资、时间成本）
- 内部资源成本（办公场地、设备等）
- 管理成本

**优势**:
- ✅ 利润留在公司内部
- ✅ 更好的质量控制
- ✅ 更快的响应速度
- ✅ 更好的客户关系维护
- ✅ 灵活调整和优化

**劣势**:
- ❌ 可能成本较高（人力成本）
- ❌ 增加内部团队工作负荷
- ❌ 需要内部团队具备相应专业能力

### 12.2 供应商交付特点

**适用场景**:
- 供应商有更强的专业能力或规模优势
- 需要降低内部团队工作负荷
- 供应商成本更低
- 需要快速扩展服务能力

**成本构成**:
- 供应商报价（直接成本）
- 供应商管理成本（沟通、协调等）

**优势**:
- ✅ 可能成本更低（供应商规模效应）
- ✅ 专业度可能更高（供应商专注特定领域）
- ✅ 减少内部团队工作负荷
- ✅ 快速扩展服务能力

**劣势**:
- ❌ 利润需要分配给供应商
- ❌ 质量控制相对困难
- ❌ 响应速度可能较慢
- ❌ 客户关系维护相对困难

### 12.3 选择决策建议

**选择内部交付的情况**:
1. 内部团队有足够专业能力
2. 内部成本低于供应商报价
3. 需要更好的质量控制和客户关系
4. 服务是公司核心业务

**选择供应商交付的情况**:
1. 供应商有更强的专业能力或规模优势
2. 供应商成本明显低于内部成本
3. 需要快速扩展服务能力
4. 服务不是公司核心业务

**混合模式**:
- 一个订单的不同服务项可以分别选择内部交付或供应商交付
- 根据每个服务项的特点和成本效益选择最优方案

---

---

## 十三、文件存储方案详细说明

### 13.1 文件存储架构

**存储架构**:
- **OSS存储**: 文件实际存储在阿里云OSS
- **数据库存储**: 文件元数据存储在 `file_storage` 表
- **关联方式**: 通过 `business_type` 和 `business_id` 关联到具体业务对象

**支持的业务类型**:
- `EXPENSE`: 报销凭证文件
- `CONTRACT`: 合同文件
- `ORDER`: 订单文件
- `ORDER_ITEM`: 订单项文件
- `SERVICE`: 服务文档

### 13.2 OSS存储方案

**存储位置**: 阿里云OSS（Object Storage Service）

**存储路径规范**:
```
oss://{bucket}/{business_type}/{year}/{month}/{business_id}_{file_type}_{index}.{ext}
```

**示例**:
```
oss://bantuqifu-dev/expenses/2024/12/EXP-20241213-001_invoice_1.jpg
oss://bantuqifu-dev/contracts/2024/12/CONTRACT-20241213-001_signed_1.pdf
oss://bantuqifu-dev/orders/2024/12/ORDER-20241213-001_attachment_1.docx
```

**文件命名规则**:
- `{business_id}`: 业务对象ID（如报销单号、合同号等）
- `{file_type}`: 文件类型标识（invoice=发票, receipt=收据, contract=合同等）
- `{index}`: 序号（同一业务对象的多个文件）
- `{ext}`: 文件扩展名

### 13.3 文件元数据说明

**必需字段**:
- `file_name`: 原始文件名（用户上传时的文件名）
- `file_size`: 文件大小（字节），用于显示和限制
- `file_md5`: 文件MD5值，用于：
  - 校验文件完整性
  - 去重（相同MD5的文件可以复用）
  - 验证文件是否被篡改
- `oss_url`: OSS访问URL（完整URL，支持CDN加速）

**可选字段**:
- `mime_type`: MIME类型，用于前端正确显示文件
- `file_extension`: 文件扩展名，用于快速识别文件类型
- `description`: 文件描述，用户可以添加备注
- `tags`: 文件标签（JSON数组），用于分类和搜索

### 13.4 文件上传流程

1. **前端上传文件到OSS**:
   - 使用OSS客户端SDK上传文件
   - 计算文件MD5值
   - 生成唯一的OSS路径
   - 获取OSS文件URL

2. **存储文件元数据到数据库**:
   - 创建 `file_storage` 记录
   - 存储文件名、大小、MD5、OSS地址等完整信息
   - 关联到业务对象（`business_type` + `business_id`）

3. **文件展示**:
   - 查询 `file_storage` 表获取文件列表
   - 显示文件名、大小、上传时间等信息
   - 使用OSS URL显示或下载文件

### 13.5 文件管理功能

**文件上传**:
- 支持单文件和多文件上传
- 支持图片（jpg, png, gif, webp）和文档（pdf, doc, docx, xls, xlsx）
- 文件大小限制：单个文件不超过50MB
- 自动计算MD5值，用于去重和校验

**文件查询**:
- 按业务类型和业务ID查询文件列表
- 按文件类型、标签、上传时间等条件筛选
- 支持文件搜索（按文件名、描述等）

**文件删除**:
- 软删除：设置 `status='DELETED'`，保留记录
- 物理删除：从OSS删除文件（可选）
- 删除报销单/合同时，可以级联删除关联的文件

**文件访问**:
- 使用OSS的预签名URL（私有文件）
- 使用CDN加速URL（公开文件）
- 设置访问权限（`is_public` 字段）

**文件校验**:
- 下载文件时，使用MD5值校验文件完整性
- 检测文件是否被篡改
- 支持文件去重（相同MD5的文件可以复用）

### 13.6 文件类型说明

**报销凭证文件** (`EXPENSE_PROOF`):
- 发票、收据、银行转账凭证等
- 关联到 `biz_expense_records` 表

**合同文件** (`CONTRACT`):
- 客户合同、供应商合同、服务协议等
- 关联到合同表（如 `contracts` 表）

**订单文件** (`ORDER_FILE`):
- 订单附件、客户需求文档等
- 关联到 `orders` 表

**订单项文件** (`ORDER_ITEM_FILE`):
- 服务项相关文档、交付物等
- 关联到 `order_items` 表

**服务文档** (`SERVICE_DOC`):
- 服务说明文档、操作手册等
- 关联到 `products` 表

### 13.7 文件安全与权限

**访问控制**:
- 私有文件：使用预签名URL，设置过期时间
- 公开文件：使用CDN加速URL，直接访问
- 权限检查：根据用户角色和业务对象权限控制访问

**文件校验**:
- MD5校验：确保文件完整性
- 文件类型检查：限制允许的文件类型
- 文件大小限制：防止过大文件

**文件备份**:
- OSS自动备份（OSS配置）
- 数据库记录保留（即使文件删除，元数据保留）
- 支持文件归档（`status='ARCHIVED'`）

---

**文档版本**: v2.4  
**最后更新**: 2024-12-13  
**更新内容**: 
- 添加内部交付支持，支持内部团队和外部供应商统一管理
- 重新设计文件存储方案，创建 `file_storage` 表统一管理所有文件元数据
- 文件元数据包含：文件名、大小、MD5、创建时间、OSS地址等完整信息
- 支持多种业务类型：报销凭证、合同、订单文件等
- **简化销售价格表设计**：一个产品一条记录包含所有等级的价格（简化维护）
- 更新待确认事项为已确认状态
**维护人**: 开发团队
