# 服务与供应商管理设计文档

**创建日期**: 2024-12-13  
**版本**: v2.0  
**状态**: 设计阶段

---

## 一、设计目标

基于现有 `schema_v1.sql` 数据库结构，重新设计服务和供应商管理环节，实现以下核心需求：

1. **多供应商支持**: 一个服务可以由多个供应商提供，支持供应商竞争和选择
2. **内部交付支持**: 公司内部团队也可以提供服务，支持内部交付和供应商交付两种模式
3. **供应商成本版本控制**: 供应商报价变更不影响历史订单的成本核算
4. **多等级多币种价格体系**: 根据客户等级提供不同价格，支持 CNY 和 IDR 双币种
5. **项目执行进度管理**: 标准执行时长、阶段划分、进度预警
6. **精确利润核算**: 支持供应商成本、内部成本、浮动成本（报销）的精确归集

---

## 二、当前数据库结构分析

### 2.1 现有表结构

#### Products 表（产品/服务表）
- **问题**: 价格字段硬编码在表中（`price_cost_idr`, `price_channel_cny`, `price_direct_idr` 等）
- **问题**: 单一供应商关联（`vendor_id`），不支持多供应商
- **问题**: 缺少标准执行时长字段

#### Organizations 表（组织表）
- **类型**: `internal`（内部组织）、`vendor`（供应商）、`agent`（渠道商）
- **供应商**: `organization_type = 'vendor'` 的组织即为供应商
- **内部团队**: `organization_type = 'internal'` 的组织可以作为服务提供方（内部交付）
- **业务场景**: 一个服务可以选择内部交付（由内部团队执行）或供应商交付（外包给外部供应商）

#### Customer Levels 表（客户等级表）
- **等级代码**: `code` 字段（如 '2', '3', '4', '5', '6'）
- **等级名称**: 央企总部和龙头企业、国有企业和上市公司、非上市品牌公司、中小型企业、个人创业小公司

#### Order Items 表（订单项表）
- **当前**: 缺少供应商关联和成本快照字段

---

## 三、核心设计思路

### 3.1 产品表瘦身

**原则**: 产品表只保留基础属性，价格和供应商关系剥离到独立表

**修改**:
- 保留产品基础信息（名称、编码、分类、描述等）
- 添加标准执行时长字段
- 添加是否允许多供应商标志
- **废弃**（标记为 deprecated）: 所有硬编码的价格字段

### 3.2 销售价格体系表 (`product_price_list`)

**设计**: Product × Customer Level 矩阵，存储多币种价格

**核心字段**:
- `product_id`: 产品ID
- `level_code`: 客户等级代码（关联 `customer_levels.code`）
- `price_cny`: 人民币售价
- `price_idr`: 印尼盾售价
- `is_active`: 是否启用

**业务规则**:
- 同一产品在同一客户等级下只能有一个有效价格
- 支持价格生效时间控制（通过 `is_active` 和 `created_at`）

### 3.3 服务提供方成本版本控制表 (`supplier_cost_history`)

**设计**: 记录服务提供方（包括外部供应商和内部团队）对每个服务的成本报价历史，支持版本控制

**核心概念**:
- **外部供应商**: `organization_type = 'vendor'` 的组织
- **内部团队**: `organization_type = 'internal'` 的组织（如：企业服务组、签证组、财税组、猎头组）
- **统一管理**: 无论是内部交付还是供应商交付，都使用同一张表记录成本，通过 `supplier_id` 关联的组织类型区分

**核心字段**:
- `product_id`: 服务ID
- `supplier_id`: 服务提供方ID（可以是 `organizations.id` where `organization_type='vendor'` 或 `organization_type='internal'`）
- `delivery_type`: 交付类型（`INTERNAL`=内部交付，`VENDOR`=供应商交付）
- `version`: 版本号
- `cost_cny`: 人民币成本
- `cost_idr`: 印尼盾成本
- `effective_start_at`: 生效开始时间
- `effective_end_at`: 失效时间（NULL 表示当前有效）
- `is_current`: 是否为当前最新报价

**业务规则**:
- 同一服务提供方对同一服务在同一时间段只能有一个有效报价
- 新报价创建时，自动将旧报价的 `effective_end_at` 设为新报价的 `effective_start_at`，`is_current` 设为 0
- 订单创建时，必须关联到具体的成本版本记录 ID
- **内部交付成本**: 内部团队的成本可能是人力成本、时间成本等，需要统一转换为货币成本
- **供应商交付成本**: 外部供应商的报价直接作为成本

### 3.4 服务执行阶段模板表 (`service_stage_templates`)

**设计**: 定义每个服务的标准执行流程和阶段时长

**核心字段**:
- `product_id`: 服务ID
- `stage_name`: 阶段名称（如：资料收集、任务执行、提交审批、任务完成）
- `stage_order`: 排序（1, 2, 3, 4）
- `standard_days`: 该阶段标准耗时（天）
- `is_milestone`: 是否为关键里程碑

**业务规则**:
- 每个服务至少需要定义一个阶段模板
- 阶段顺序必须连续（1, 2, 3, 4...）
- 标准执行总时长 = 所有阶段 `standard_days` 之和

### 3.5 订单项扩展 (`order_items`)

**设计**: 在订单项中记录服务提供方选择和成本快照

**新增字段**:
- `selected_supplier_id`: 执行该项的服务提供方ID（可以是内部团队或外部供应商）
- `delivery_type`: 交付类型（`INTERNAL`=内部交付，`VENDOR`=供应商交付）
- `supplier_cost_history_id`: 关联的成本版本ID
- `snapshot_cost_cny`: 下单时的RMB成本快照
- `snapshot_cost_idr`: 下单时的IDR成本快照
- `estimated_profit_cny`: 预估毛利（CNY）（计算字段）

**业务规则**:
- 订单创建时，必须选择服务提供方（内部团队或外部供应商）并记录成本快照
- 成本快照用于利润核算，不受后续服务提供方报价变更影响
- **内部交付**: 选择内部团队时，`delivery_type = 'INTERNAL'`，成本可能是人力成本
- **供应商交付**: 选择外部供应商时，`delivery_type = 'VENDOR'`，成本是供应商报价

---

## 四、数据库 Schema 设计

### 4.1 修改产品表 (`products`)

```sql
-- 添加标准执行时长和多供应商支持字段
ALTER TABLE `products` 
ADD COLUMN `std_duration_days` INT DEFAULT 7 COMMENT '标准执行总时长(天)',
ADD COLUMN `allow_multi_vendor` TINYINT(1) DEFAULT 1 COMMENT '是否允许多供应商接单（1=允许，0=单一供应商）',
ADD COLUMN `default_supplier_id` CHAR(36) DEFAULT NULL COMMENT '默认供应商ID（当allow_multi_vendor=0时使用）';

-- 添加外键约束
ALTER TABLE `products`
ADD CONSTRAINT `fk_products_default_supplier` 
FOREIGN KEY (`default_supplier_id`) REFERENCES `organizations` (`id`) ON DELETE SET NULL;

-- 注意：旧的价格字段（price_cost_idr, price_channel_cny等）保留但不使用
-- 未来可以通过数据迁移脚本将历史数据迁移到新表后删除
```

### 4.2 创建销售价格体系表 (`product_price_list`)

```sql
DROP TABLE IF EXISTS `product_price_list`;

CREATE TABLE `product_price_list` (
  `id` CHAR(36) NOT NULL DEFAULT (UUID()),
  `product_id` CHAR(36) NOT NULL COMMENT '关联服务/产品ID',
  `level_code` VARCHAR(50) NOT NULL COMMENT '关联客户等级代码 (对应 customer_levels.code)',
  `price_cny` DECIMAL(18,2) DEFAULT '0.00' COMMENT '人民币售价',
  `price_idr` DECIMAL(18,2) DEFAULT '0.00' COMMENT '印尼盾售价',
  `is_active` TINYINT(1) DEFAULT '1' COMMENT '是否启用',
  `effective_from` DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '生效开始时间',
  `effective_to` DATETIME DEFAULT NULL COMMENT '生效结束时间（NULL表示一直有效）',
  `created_by` CHAR(36) DEFAULT NULL COMMENT '创建人ID',
  `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  -- 联合唯一索引：确保同一个产品在同一个等级下只有一个有效价格条目
  UNIQUE KEY `ux_product_level_active` (`product_id`, `level_code`, `is_active`),
  KEY `ix_price_list_product` (`product_id`),
  KEY `ix_price_list_level` (`level_code`),
  KEY `ix_price_list_active` (`is_active`),
  CONSTRAINT `fk_price_list_product` FOREIGN KEY (`product_id`) REFERENCES `products` (`id`) ON DELETE CASCADE,
  CONSTRAINT `fk_price_list_level` FOREIGN KEY (`level_code`) REFERENCES `customer_levels` (`code`) ON DELETE CASCADE,
  CONSTRAINT `fk_price_list_creator` FOREIGN KEY (`created_by`) REFERENCES `users` (`id`) ON DELETE SET NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='销售价格体系表：多等级多币种';
```

### 4.3 创建服务提供方成本版本表 (`supplier_cost_history`)

**表名说明**: 虽然表名为 `supplier_cost_history`，但实际上同时支持外部供应商和内部团队的成本管理。

```sql
DROP TABLE IF EXISTS `supplier_cost_history`;

CREATE TABLE `supplier_cost_history` (
  `id` CHAR(36) NOT NULL DEFAULT (UUID()),
  `product_id` CHAR(36) NOT NULL COMMENT '关联服务ID',
  `supplier_id` CHAR(36) NOT NULL COMMENT '关联服务提供方ID (可以是 organizations表 type=vendor 或 type=internal)',
  `delivery_type` ENUM('INTERNAL', 'VENDOR') NOT NULL COMMENT '交付类型: INTERNAL=内部交付, VENDOR=供应商交付',
  `version` INT NOT NULL DEFAULT 1 COMMENT '版本号（同一服务提供方同一服务的版本号递增）',
  `cost_cny` DECIMAL(18,2) DEFAULT '0.00' COMMENT '人民币成本',
  `cost_idr` DECIMAL(18,2) DEFAULT '0.00' COMMENT '印尼盾成本',
  `effective_start_at` DATETIME NOT NULL COMMENT '生效开始时间',
  `effective_end_at` DATETIME DEFAULT NULL COMMENT '失效时间 (NULL代表当前一直有效)',
  `is_current` TINYINT(1) DEFAULT '1' COMMENT '是否为当前最新报价',
  `notes` TEXT COMMENT '备注说明（如：涨价原因、特殊条件、内部成本计算方式等）',
  `created_by` CHAR(36) DEFAULT NULL COMMENT '创建人ID',
  `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `ix_cost_lookup` (`product_id`, `supplier_id`, `is_current`),
  KEY `ix_cost_product` (`product_id`),
  KEY `ix_cost_supplier` (`supplier_id`),
  KEY `ix_cost_delivery_type` (`delivery_type`),
  KEY `ix_cost_effective` (`effective_start_at`, `effective_end_at`),
  CONSTRAINT `fk_cost_product` FOREIGN KEY (`product_id`) REFERENCES `products` (`id`) ON DELETE CASCADE,
  CONSTRAINT `fk_cost_supplier` FOREIGN KEY (`supplier_id`) REFERENCES `organizations` (`id`) ON DELETE CASCADE,
  CONSTRAINT `fk_cost_creator` FOREIGN KEY (`created_by`) REFERENCES `users` (`id`) ON DELETE SET NULL,
  -- 确保同一服务提供方同一服务在同一时间段只有一个有效报价
  CONSTRAINT `chk_cost_nonneg` CHECK (
    (COALESCE(`cost_cny`, 0) >= 0) AND 
    (COALESCE(`cost_idr`, 0) >= 0)
  ),
  -- 确保 delivery_type 与 organizations.organization_type 一致
  -- 注意：这个约束需要在应用层保证，数据库层面难以实现跨表检查
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='服务提供方成本历史表(版本控制，支持内部交付和供应商交付)';
```

### 4.4 创建服务执行阶段模板表 (`service_stage_templates`)

```sql
DROP TABLE IF EXISTS `service_stage_templates`;

CREATE TABLE `service_stage_templates` (
  `id` CHAR(36) NOT NULL DEFAULT (UUID()),
  `product_id` CHAR(36) NOT NULL COMMENT '关联服务ID',
  `stage_name_zh` VARCHAR(100) NOT NULL COMMENT '阶段名称（中文）',
  `stage_name_id` VARCHAR(100) DEFAULT NULL COMMENT '阶段名称（印尼语）',
  `stage_order` INT NOT NULL COMMENT '排序 (1,2,3,4...)',
  `standard_days` INT DEFAULT 0 COMMENT '该阶段标准耗时(天)',
  `is_milestone` TINYINT(1) DEFAULT '0' COMMENT '是否为关键里程碑',
  `description` TEXT COMMENT '阶段描述',
  `created_by` CHAR(36) DEFAULT NULL COMMENT '创建人ID',
  `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `ix_stage_tpl_product` (`product_id`),
  KEY `ix_stage_tpl_order` (`product_id`, `stage_order`),
  CONSTRAINT `fk_stage_tpl_product` FOREIGN KEY (`product_id`) REFERENCES `products` (`id`) ON DELETE CASCADE,
  CONSTRAINT `fk_stage_tpl_creator` FOREIGN KEY (`created_by`) REFERENCES `users` (`id`) ON DELETE SET NULL,
  CONSTRAINT `chk_stage_order_positive` CHECK (`stage_order` > 0),
  CONSTRAINT `chk_stage_days_nonneg` CHECK (`standard_days` >= 0)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='服务执行阶段标准模板';
```

### 4.5 修改订单项表 (`order_items`)

```sql
-- 添加服务提供方选择和成本快照字段
ALTER TABLE `order_items`
-- 1. 记录选择了哪个服务提供方（内部团队或外部供应商）
ADD COLUMN `selected_supplier_id` CHAR(36) DEFAULT NULL COMMENT '执行该项的服务提供方ID（可以是内部团队或外部供应商）',

-- 2. 交付类型（明确是内部交付还是供应商交付）
ADD COLUMN `delivery_type` ENUM('INTERNAL', 'VENDOR') DEFAULT NULL COMMENT '交付类型: INTERNAL=内部交付, VENDOR=供应商交付',

-- 3. 核心：记录成本来源的版本ID (关联 supplier_cost_history.id)
ADD COLUMN `supplier_cost_history_id` CHAR(36) DEFAULT NULL COMMENT '关联的成本版本ID',

-- 4. 成本快照 (双重保险，防止历史表被删，直接把金额固化在订单行里)
ADD COLUMN `snapshot_cost_cny` DECIMAL(18,2) DEFAULT '0.00' COMMENT '下单时的RMB成本快照',
ADD COLUMN `snapshot_cost_idr` DECIMAL(18,2) DEFAULT '0.00' COMMENT '下单时的IDR成本快照',

-- 5. 利润字段（存储字段，便于报表查询）
ADD COLUMN `estimated_profit_cny` DECIMAL(18,2) DEFAULT '0.00' COMMENT '预估毛利(CNY)',
ADD COLUMN `estimated_profit_idr` DECIMAL(18,2) DEFAULT '0.00' COMMENT '预估毛利(IDR)';

-- 添加外键约束
ALTER TABLE `order_items`
ADD CONSTRAINT `fk_order_item_supplier` 
FOREIGN KEY (`selected_supplier_id`) REFERENCES `organizations` (`id`) ON DELETE SET NULL,

ADD CONSTRAINT `fk_order_item_cost_ver` 
FOREIGN KEY (`supplier_cost_history_id`) REFERENCES `supplier_cost_history` (`id`) ON DELETE SET NULL;

-- 添加索引
ALTER TABLE `order_items`
ADD KEY `ix_order_items_supplier` (`selected_supplier_id`),
ADD KEY `ix_order_items_delivery_type` (`delivery_type`),
ADD KEY `ix_order_items_cost_history` (`supplier_cost_history_id`);

-- 添加检查约束：确保 delivery_type 和 selected_supplier_id 同时存在或同时为空
ALTER TABLE `order_items`
ADD CONSTRAINT `chk_order_items_delivery` 
CHECK (
  (`selected_supplier_id` IS NULL AND `delivery_type` IS NULL) OR
  (`selected_supplier_id` IS NOT NULL AND `delivery_type` IS NOT NULL)
);
```

### 4.6 修改订单阶段表 (`order_stages`) 以支持进度预警

**设计说明**: 
- 根据业务需求，订单阶段应该关联到**订单项**（`order_items`），而不是整个订单
- 因为一个订单可能包含多个服务项，每个服务项的执行进度是独立的
- 如果 `order_item_id` 为空，则阶段关联到整个订单（向后兼容）

```sql
-- 添加订单项关联（核心：阶段应该关联到具体的订单项）
ALTER TABLE `order_stages`
ADD COLUMN `order_item_id` CHAR(36) DEFAULT NULL COMMENT '关联的订单项ID（核心字段，阶段关联到具体的服务项）';

-- 添加进度预警字段
ALTER TABLE `order_stages`
ADD COLUMN `expected_start_date` DATE DEFAULT NULL COMMENT '预期开始日期',
ADD COLUMN `expected_end_date` DATE DEFAULT NULL COMMENT '预期结束日期(根据标准时长计算)',
ADD COLUMN `actual_start_date` DATE DEFAULT NULL COMMENT '实际开始日期',
ADD COLUMN `actual_end_date` DATE DEFAULT NULL COMMENT '实际结束日期',
ADD COLUMN `is_overdue` TINYINT(1) DEFAULT '0' COMMENT '是否已超期',
ADD COLUMN `alert_level` VARCHAR(20) DEFAULT 'normal' COMMENT '预警级别: normal, warning, critical',
ADD COLUMN `stage_template_id` CHAR(36) DEFAULT NULL COMMENT '关联的阶段模板ID';

-- 添加外键约束
ALTER TABLE `order_stages`
ADD CONSTRAINT `fk_order_stage_order_item` 
FOREIGN KEY (`order_item_id`) REFERENCES `order_items` (`id`) ON DELETE CASCADE,

ADD CONSTRAINT `fk_order_stage_template` 
FOREIGN KEY (`stage_template_id`) REFERENCES `service_stage_templates` (`id`) ON DELETE SET NULL;

-- 添加索引
ALTER TABLE `order_stages`
ADD KEY `ix_order_stages_order_item` (`order_item_id`),
ADD KEY `ix_order_stages_expected` (`expected_end_date`),
ADD KEY `ix_order_stages_overdue` (`is_overdue`),
ADD KEY `ix_order_stages_alert` (`alert_level`);

-- 添加检查约束：确保 order_id 和 order_item_id 至少有一个不为空
ALTER TABLE `order_stages`
ADD CONSTRAINT `chk_order_stages_reference` 
CHECK (`order_id` IS NOT NULL);
```

---

## 五、业务逻辑与数据流向

### 5.1 场景一：销售报价查询

**业务场景**: 销售需要为客户（已知客户等级）查询服务价格

**流程**:
1. **输入**: 客户ID（已知客户等级）、服务ID
2. **查询客户等级**: 
   ```sql
   SELECT level_code FROM customers WHERE id = ?
   ```
3. **查询价格**: 
   ```sql
   SELECT price_cny, price_idr 
   FROM product_price_list 
   WHERE product_id = ? 
     AND level_code = ? 
     AND is_active = 1
     AND (effective_to IS NULL OR effective_to > NOW())
   ```
4. **返回**: 人民币价格和印尼盾价格

**API 设计**:
```
GET /api/v1/products/{product_id}/price?customer_id={customer_id}
Response: {
  "product_id": "...",
  "level_code": "3",
  "price_cny": 10000.00,
  "price_idr": 20000000.00,
  "currency": "CNY"  // 默认货币
}
```

### 5.2 场景二：中台 (KK) 派单与服务提供方选择

**业务场景**: 订单生成后，KK 需要为订单项选择执行服务提供方（内部团队或外部供应商）

**流程**:
1. **查询可用服务提供方（包括内部团队和外部供应商）**: 
   ```sql
   SELECT 
     sch.id,
     sch.supplier_id,
     sch.delivery_type,
     o.name AS supplier_name,
     o.organization_type,
     sch.cost_cny,
     sch.cost_idr,
     sch.version,
     sch.notes
   FROM supplier_cost_history sch
   JOIN organizations o ON sch.supplier_id = o.id
   WHERE sch.product_id = ?
     AND sch.is_current = 1
     AND o.is_active = 1
     AND (
       o.organization_type = 'vendor' OR  -- 外部供应商
       o.organization_type = 'internal'   -- 内部团队
     )
   ORDER BY 
     sch.delivery_type ASC,  -- 先显示内部交付，再显示供应商交付
     sch.cost_cny ASC        -- 按成本排序
   ```
2. **决策**: KK 根据以下因素选择服务提供方：
   - **成本**: 内部交付成本 vs 供应商报价
   - **速度**: 内部团队的执行速度 vs 供应商的执行速度
   - **质量**: 内部团队的专业度 vs 供应商的专业度
   - **利润分配**: 内部交付的利润留在公司内部，供应商交付需要支付供应商成本
   - **执行周期长度**: 内部团队的执行周期 vs 供应商的执行周期
3. **更新订单项**:
   ```sql
   UPDATE order_items 
   SET 
     selected_supplier_id = ?,
     delivery_type = ?,  -- 'INTERNAL' 或 'VENDOR'
     supplier_cost_history_id = ?,
     snapshot_cost_cny = ?,
     snapshot_cost_idr = ?,
     estimated_profit_cny = unit_price - ?,
     estimated_profit_idr = (unit_price * exchange_rate) - ?
   WHERE id = ?
   ```

**API 设计**:
```
GET /api/v1/products/{product_id}/providers
Response: {
  "product_id": "...",
  "product_name": "公司注册",
  "providers": [
    {
      "provider_id": "...",
      "provider_name": "企业服务组",
      "delivery_type": "INTERNAL",
      "organization_type": "internal",
      "cost_cny": 1500.00,
      "cost_idr": 3000000.00,
      "version": 1,
      "is_current": true,
      "notes": "内部团队人力成本"
    },
    {
      "provider_id": "...",
      "provider_name": "供应商A",
      "delivery_type": "VENDOR",
      "organization_type": "vendor",
      "cost_cny": 2000.00,
      "cost_idr": 4000000.00,
      "version": 1,
      "is_current": true,
      "notes": "供应商报价"
    },
    ...
  ]
}

POST /api/v1/order-items/{order_item_id}/assign-provider
Request: {
  "provider_id": "...",
  "delivery_type": "INTERNAL",  // 或 "VENDOR"
  "supplier_cost_history_id": "..."
}
```

**业务说明**:
- **内部交付优势**: 
  - 利润留在公司内部
  - 更好的质量控制
  - 更快的响应速度
  - 更好的客户关系维护
- **供应商交付优势**:
  - 可能成本更低（供应商规模效应）
  - 专业度可能更高（供应商专注特定领域）
  - 减少内部团队工作负荷

### 5.3 场景三：服务提供方成本更新（内部团队或供应商）

**业务场景**: 内部团队成本调整或供应商通知我们下个月涨价

**流程**:
1. **查询当前成本**:
   ```sql
   SELECT * FROM supplier_cost_history 
   WHERE product_id = ? 
     AND supplier_id = ? 
     AND is_current = 1
   ```
2. **关闭旧成本记录**:
   ```sql
   UPDATE supplier_cost_history 
   SET 
     effective_end_at = NOW(),
     is_current = 0
   WHERE id = ?
   ```
3. **创建新成本记录**:
   ```sql
   INSERT INTO supplier_cost_history (
     product_id, supplier_id, delivery_type, version, 
     cost_cny, cost_idr,
     effective_start_at, is_current, created_by, notes
   ) VALUES (
     ?, ?, ?, 
     (SELECT COALESCE(MAX(version), 0) + 1 FROM supplier_cost_history WHERE product_id = ? AND supplier_id = ?),
     ?, ?, NOW(), 1, ?, ?
   )
   ```
4. **影响分析**:
   - **新订单**: 自动关联到新成本记录
   - **旧订单**: `order_items.supplier_cost_history_id` 仍指向旧成本记录，利润核算不受影响

**API 设计**:
```
POST /api/v1/providers/{provider_id}/products/{product_id}/cost
Request: {
  "delivery_type": "VENDOR",  // 或 "INTERNAL"
  "cost_cny": 2500.00,
  "cost_idr": 5000000.00,
  "effective_from": "2025-01-01T00:00:00Z",
  "notes": "下个月涨价"  // 或 "内部人力成本调整"
}

Response: {
  "id": "...",
  "product_id": "...",
  "provider_id": "...",
  "delivery_type": "VENDOR",
  "version": 2,
  "cost_cny": 2500.00,
  "cost_idr": 5000000.00,
  "effective_start_at": "2025-01-01T00:00:00Z",
  "is_current": true
}
```

**业务说明**:
- **内部团队成本更新**: 可能是人力成本调整、效率提升导致成本降低等
- **供应商成本更新**: 供应商主动涨价/降价，或我们重新谈判价格
- **版本控制**: 所有成本变更都记录历史版本，确保历史订单成本不变

### 5.4 场景四：订单创建时的价格和成本快照

**业务场景**: 销售创建订单，系统自动记录价格和成本快照

**流程**:
1. **创建订单项时**:
   - 根据客户等级查询销售价格（`product_price_list`）
   - 设置订单项的 `unit_price` 和 `currency_code`
2. **KK 分配供应商后**:
   - 根据选择的供应商，查询当前成本（`supplier_cost_history`）
   - 更新订单项的成本快照字段
   - 计算预估利润

**代码示例**:
```python
async def create_order_item(order_id: str, product_id: str, customer_id: str):
    # 1. 查询客户等级
    customer = await get_customer(customer_id)
    level_code = customer.level_code
    
    # 2. 查询销售价格
    price = await get_product_price(product_id, level_code)
    
    # 3. 创建订单项（此时供应商未分配）
    order_item = OrderItem(
        order_id=order_id,
        product_id=product_id,
        unit_price=price.price_cny,
        currency_code='CNY',
        # selected_supplier_id = NULL (待分配)
    )
    
    # 4. KK 分配服务提供方后（内部团队或外部供应商）
    provider_cost = await get_current_provider_cost(product_id, provider_id)
    order_item.selected_supplier_id = provider_id
    order_item.delivery_type = provider_cost.delivery_type  # 'INTERNAL' 或 'VENDOR'
    order_item.supplier_cost_history_id = provider_cost.id
    order_item.snapshot_cost_cny = provider_cost.cost_cny
    order_item.snapshot_cost_idr = provider_cost.cost_idr
    order_item.estimated_profit_cny = price.price_cny - provider_cost.cost_cny
    order_item.estimated_profit_idr = price.price_idr - provider_cost.cost_idr
```

### 5.5 场景五：订单阶段初始化与进度预警

**业务场景**: 订单项创建后，根据服务模板自动创建执行阶段，并定时检查进度预警

#### 5.5.1 订单阶段初始化流程

**触发时机**: 订单项创建且供应商已分配后

**流程**:
1. **查询服务阶段模板**:
   ```sql
   SELECT * FROM service_stage_templates 
   WHERE product_id = ? 
   ORDER BY stage_order ASC
   ```
2. **为每个阶段创建订单阶段记录**:
   ```python
   async def initialize_order_stages(order_item_id: str, product_id: str):
       # 1. 查询阶段模板
       templates = await get_stage_templates(product_id)
       
       # 2. 获取订单项信息
       order_item = await get_order_item(order_item_id)
       order = await get_order(order_item.order_id)
       
       # 3. 计算起始日期（从订单创建日期或预期开始日期开始）
       start_date = order_item.expected_start_date or order.created_at.date()
       current_date = start_date
       
       # 4. 为每个阶段创建记录
       for template in templates:
           expected_start = current_date
           expected_end = current_date + timedelta(days=template.standard_days)
           
           stage = OrderStage(
               order_id=order_item.order_id,
               order_item_id=order_item_id,  # 关键：关联到订单项
               stage_name=template.stage_name_zh,
               stage_code=f"stage_{template.stage_order}",
               stage_order=template.stage_order,
               stage_template_id=template.id,
               expected_start_date=expected_start,
               expected_end_date=expected_end,
               status='pending',
               alert_level='normal'
           )
           await create_order_stage(stage)
           
           # 下一个阶段从当前阶段结束日期开始
           current_date = expected_end + timedelta(days=1)
       
       # 5. 更新订单项的预期完成日期
       order_item.expected_completion_date = current_date - timedelta(days=1)
   ```

#### 5.5.2 进度预警机制

**定时任务**: 每小时或每天执行一次

**流程**:
1. **查询即将超期或已超期的阶段**:
   ```sql
   SELECT 
     os.*,
     oi.product_id,
     oi.product_name_zh,
     o.order_number,
     o.customer_id,
     c.name AS customer_name
   FROM order_stages os
   JOIN order_items oi ON os.order_item_id = oi.id
   JOIN orders o ON oi.order_id = o.id
   JOIN customers c ON o.customer_id = c.id
   WHERE os.status != 'completed'
     AND os.expected_end_date IS NOT NULL
     AND (
       -- 即将超期（3天内）
       (os.expected_end_date BETWEEN CURDATE() AND DATE_ADD(CURDATE(), INTERVAL 3 DAY))
       OR
       -- 已超期
       (os.expected_end_date < CURDATE())
     )
     AND os.is_overdue = 0
   ```
2. **更新预警状态**:
   ```sql
   UPDATE order_stages 
   SET 
     is_overdue = CASE 
       WHEN expected_end_date < CURDATE() THEN 1 
       ELSE 0 
     END,
     alert_level = CASE 
       WHEN expected_end_date < CURDATE() THEN 'critical'
       WHEN DATEDIFF(expected_end_date, CURDATE()) <= 1 THEN 'critical'
       WHEN DATEDIFF(expected_end_date, CURDATE()) <= 3 THEN 'warning'
       ELSE 'normal'
     END
   WHERE id IN (...)
   ```
3. **发送通知**: 
   - 通知订单项负责人（`order_stages.assigned_to_user_id`）
   - 通知订单销售（`orders.sales_user_id`）
   - 通知中台负责人（KK）

**API 设计**:
```
GET /api/v1/order-stages/overdue?alert_level=critical
Response: {
  "overdue_stages": [
    {
      "order_id": "...",
      "order_item_id": "...",
      "stage_name": "资料收集",
      "expected_end_date": "2024-12-10",
      "overdue_days": 3,
      "alert_level": "critical"
    },
    ...
  ]
}
```

---

## 六、利润核算逻辑

### 6.1 订单级利润核算

**公式**:
```
订单毛利 = 订单收入 - 服务提供方成本（内部成本+供应商成本）- 销售浮动成本 - 执行浮动成本
```

**说明**:
- **服务提供方成本**: 包括内部交付成本（内部团队人力成本）和供应商交付成本（供应商报价）
- **统一核算**: 无论是内部交付还是供应商交付，成本都统一在 `order_items.snapshot_cost_cny` 中记录

**SQL 查询**:
```sql
SELECT 
    o.id AS order_id,
    o.order_number,
    o.total_amount AS order_revenue,
    
    -- 服务提供方成本（从订单项汇总，包括内部成本和供应商成本）
    (SELECT IFNULL(SUM(snapshot_cost_cny), 0) 
     FROM order_items 
     WHERE order_id = o.id) AS provider_cost,
    
    -- 内部交付成本（明细）
    (SELECT IFNULL(SUM(snapshot_cost_cny), 0) 
     FROM order_items 
     WHERE order_id = o.id 
       AND delivery_type = 'INTERNAL') AS internal_cost,
    
    -- 供应商交付成本（明细）
    (SELECT IFNULL(SUM(snapshot_cost_cny), 0) 
     FROM order_items 
     WHERE order_id = o.id 
       AND delivery_type = 'VENDOR') AS vendor_cost,
    
    -- 销售浮动成本（报销，归属 SALES）
    (SELECT IFNULL(SUM(amount), 0) 
     FROM biz_expense_records 
     WHERE order_id = o.id 
       AND cost_attribution = 'SALES' 
       AND status = 'PAID') AS sales_floating_cost,
    
    -- 执行浮动成本（报销，归属 EXECUTION）
    (SELECT IFNULL(SUM(amount), 0) 
     FROM biz_expense_records 
     WHERE order_item_id IN (
       SELECT id FROM order_items WHERE order_id = o.id
     ) 
     AND cost_attribution = 'EXECUTION' 
     AND status = 'PAID') AS execution_floating_cost,
    
    -- 最终毛利
    (o.total_amount 
     - (SELECT IFNULL(SUM(snapshot_cost_cny), 0) FROM order_items WHERE order_id = o.id)
     - (SELECT IFNULL(SUM(amount), 0) FROM biz_expense_records WHERE order_id = o.id AND cost_attribution = 'SALES' AND status = 'PAID')
     - (SELECT IFNULL(SUM(amount), 0) FROM biz_expense_records WHERE order_item_id IN (SELECT id FROM order_items WHERE order_id = o.id) AND cost_attribution = 'EXECUTION' AND status = 'PAID')
    ) AS net_profit
    
FROM orders o
WHERE o.id = ?;
```

### 6.2 订单项级利润核算

**公式**:
```
订单项毛利 = 订单项收入 - 服务提供方成本（内部成本或供应商成本）- 执行浮动成本（关联到此订单项的报销）
```

**SQL 查询**:
```sql
SELECT 
    oi.id AS order_item_id,
    oi.product_name_zh,
    oi.delivery_type,
    oi.unit_price * oi.quantity AS item_revenue,
    oi.snapshot_cost_cny AS provider_cost,
    oi.estimated_profit_cny AS estimated_profit,
    
    -- 服务提供方信息
    o.name AS provider_name,
    o.organization_type,
    
    -- 执行浮动成本（关联到此订单项的报销）
    (SELECT IFNULL(SUM(amount), 0) 
     FROM biz_expense_records 
     WHERE order_item_id = oi.id 
       AND cost_attribution = 'EXECUTION' 
       AND status = 'PAID') AS execution_floating_cost,
    
    -- 实际利润
    (oi.unit_price * oi.quantity 
     - oi.snapshot_cost_cny
     - (SELECT IFNULL(SUM(amount), 0) FROM biz_expense_records WHERE order_item_id = oi.id AND cost_attribution = 'EXECUTION' AND status = 'PAID')
    ) AS actual_profit
    
FROM order_items oi
WHERE oi.id = ?;
```

---

## 七、数据迁移方案

### 7.1 历史价格数据迁移

**目标**: 将 `products` 表中的旧价格字段迁移到 `product_price_list` 表

**步骤**:
1. **识别需要迁移的产品**:
   ```sql
   SELECT id, code, name, 
          price_direct_cny, price_direct_idr,
          price_channel_cny, price_channel_idr
   FROM products 
   WHERE price_direct_cny IS NOT NULL 
      OR price_channel_cny IS NOT NULL
   ```
2. **为每个产品创建价格记录**（假设默认客户等级为 '5' - 中小型企业）:
   ```sql
   INSERT INTO product_price_list (product_id, level_code, price_cny, price_idr)
   SELECT 
     id AS product_id,
     '5' AS level_code,  -- 默认等级
     COALESCE(price_direct_cny, price_channel_cny, 0) AS price_cny,
     COALESCE(price_direct_idr, price_channel_idr, 0) AS price_idr
   FROM products
   WHERE price_direct_cny IS NOT NULL OR price_channel_cny IS NOT NULL;
   ```
3. **验证数据**:
   ```sql
   SELECT COUNT(*) FROM product_price_list;
   SELECT * FROM product_price_list LIMIT 10;
   ```

### 7.2 历史服务提供方成本迁移

**目标**: 将 `products.vendor_id` 和 `products.price_cost_cny` 迁移到 `supplier_cost_history` 表

**步骤**:
1. **识别需要迁移的产品**:
   ```sql
   SELECT p.id, p.vendor_id, p.price_cost_cny, p.price_cost_idr, o.organization_type
   FROM products p
   LEFT JOIN organizations o ON p.vendor_id = o.id
   WHERE p.vendor_id IS NOT NULL 
     AND (p.price_cost_cny IS NOT NULL OR p.price_cost_idr IS NOT NULL)
   ```
2. **创建服务提供方成本历史记录**:
   ```sql
   INSERT INTO supplier_cost_history (
     product_id, supplier_id, delivery_type, version,
     cost_cny, cost_idr,
     effective_start_at, is_current
   )
   SELECT 
     p.id AS product_id,
     p.vendor_id AS supplier_id,
     CASE 
       WHEN o.organization_type = 'internal' THEN 'INTERNAL'
       WHEN o.organization_type = 'vendor' THEN 'VENDOR'
       ELSE 'VENDOR'  -- 默认值
     END AS delivery_type,
     1 AS version,
     COALESCE(p.price_cost_cny, 0) AS cost_cny,
     COALESCE(p.price_cost_idr, 0) AS cost_idr,
     p.created_at AS effective_start_at,
     1 AS is_current
   FROM products p
   JOIN organizations o ON p.vendor_id = o.id
   WHERE p.vendor_id IS NOT NULL 
     AND (p.price_cost_cny IS NOT NULL OR p.price_cost_idr IS NOT NULL)
     AND o.organization_type IN ('internal', 'vendor');
   ```

### 7.3 订单项服务提供方关联迁移

**目标**: 为已有订单项补充服务提供方信息（如果产品有默认服务提供方）

**步骤**:
```sql
UPDATE order_items oi
JOIN products p ON oi.product_id = p.id
JOIN organizations o ON p.vendor_id = o.id
SET 
  oi.selected_supplier_id = p.vendor_id,
  oi.delivery_type = CASE 
    WHEN o.organization_type = 'internal' THEN 'INTERNAL'
    WHEN o.organization_type = 'vendor' THEN 'VENDOR'
    ELSE 'VENDOR'
  END,
  oi.supplier_cost_history_id = (
    SELECT id FROM supplier_cost_history 
    WHERE product_id = p.id 
      AND supplier_id = p.vendor_id 
      AND is_current = 1 
    LIMIT 1
  ),
  oi.snapshot_cost_cny = COALESCE(p.price_cost_cny, 0),
  oi.snapshot_cost_idr = COALESCE(p.price_cost_idr, 0)
WHERE oi.selected_supplier_id IS NULL
  AND p.vendor_id IS NOT NULL;
```

---

## 八、API 设计要点

### 8.1 产品价格查询 API

```
GET /api/v1/products/{product_id}/prices
Query Parameters:
  - level_code: 客户等级代码（可选，不提供则返回所有等级的价格）
  - currency: CNY | IDR（可选，默认返回两种货币）

Response: {
  "product_id": "...",
  "product_name": "公司注册",
  "prices": [
    {
      "level_code": "2",
      "level_name": "央企总部和龙头企业",
      "price_cny": 50000.00,
      "price_idr": 100000000.00,
      "is_active": true
    },
    ...
  ]
}
```

### 8.2 服务提供方成本管理 API

```
GET /api/v1/products/{product_id}/providers/costs
Query Parameters:
  - delivery_type: INTERNAL | VENDOR（可选，过滤交付类型）
  - include_history: true | false（可选，是否包含历史版本，默认false）

Response: {
  "product_id": "...",
  "product_name": "公司注册",
  "providers": [
    {
      "provider_id": "...",
      "provider_name": "企业服务组",
      "delivery_type": "INTERNAL",
      "organization_type": "internal",
      "current_cost": {
        "id": "...",
        "cost_cny": 1500.00,
        "cost_idr": 3000000.00,
        "version": 1,
        "effective_from": "2024-01-01T00:00:00Z",
        "notes": "内部人力成本"
      },
      "history": [
        {
          "version": 1,
          "cost_cny": 1500.00,
          "effective_from": "2024-01-01T00:00:00Z",
          "effective_to": null
        }
      ]
    },
    {
      "provider_id": "...",
      "provider_name": "供应商A",
      "delivery_type": "VENDOR",
      "organization_type": "vendor",
      "current_cost": {
        "id": "...",
        "cost_cny": 2000.00,
        "cost_idr": 4000000.00,
        "version": 2,
        "effective_from": "2024-12-01T00:00:00Z",
        "notes": "供应商报价"
      },
      "history": [
        {
          "version": 1,
          "cost_cny": 1800.00,
          "effective_from": "2024-01-01T00:00:00Z",
          "effective_to": "2024-11-30T23:59:59Z"
        },
        {
          "version": 2,
          "cost_cny": 2000.00,
          "effective_from": "2024-12-01T00:00:00Z",
          "effective_to": null
        }
      ]
    }
  ]
}

POST /api/v1/providers/{provider_id}/products/{product_id}/costs
Request: {
  "delivery_type": "VENDOR",  // 或 "INTERNAL"
  "cost_cny": 2500.00,
  "cost_idr": 5000000.00,
  "effective_from": "2025-01-01T00:00:00Z",
  "notes": "下个月涨价"  // 或 "内部人力成本调整"
}

Response: {
  "id": "...",
  "product_id": "...",
  "provider_id": "...",
  "delivery_type": "VENDOR",
  "version": 3,
  "cost_cny": 2500.00,
  "cost_idr": 5000000.00,
  "effective_start_at": "2025-01-01T00:00:00Z",
  "is_current": true,
  "notes": "下个月涨价"
}
```

### 8.3 服务阶段模板管理 API

```
GET /api/v1/products/{product_id}/stage-templates
Response: {
  "product_id": "...",
  "total_duration_days": 7,
  "stages": [
    {
      "id": "...",
      "stage_name_zh": "资料收集",
      "stage_name_id": "Pengumpulan Dokumen",
      "stage_order": 1,
      "standard_days": 2,
      "is_milestone": false
    },
    {
      "id": "...",
      "stage_name_zh": "任务执行",
      "stage_name_id": "Pelaksanaan Tugas",
      "stage_order": 2,
      "standard_days": 4,
      "is_milestone": true
    },
    ...
  ]
}

POST /api/v1/products/{product_id}/stage-templates
Request: {
  "stages": [
    {
      "stage_name_zh": "资料收集",
      "stage_name_id": "Pengumpulan Dokumen",
      "stage_order": 1,
      "standard_days": 2
    },
    ...
  ]
}
```

---

## 九、实施计划

### 9.1 第一阶段：数据库 Schema 更新（1-2天）

- [ ] 修改 `products` 表（添加标准执行时长字段）
- [ ] 创建 `product_price_list` 表
- [ ] 创建 `supplier_cost_history` 表
- [ ] 创建 `service_stage_templates` 表
- [ ] 修改 `order_items` 表（添加供应商和成本字段）
- [ ] 修改 `order_stages` 表（添加进度预警字段）

### 9.2 第二阶段：数据迁移（1天）

- [ ] 迁移历史价格数据到 `product_price_list`
- [ ] 迁移历史供应商成本到 `supplier_cost_history`
- [ ] 为已有订单项补充供应商信息
- [ ] 数据验证和修复

### 9.3 第三阶段：业务逻辑实现（3-5天）

- [ ] 实现产品价格查询逻辑
- [ ] 实现供应商成本版本管理逻辑
- [ ] 实现订单创建时的价格和成本快照逻辑
- [ ] 实现服务阶段模板管理逻辑
- [ ] 实现进度预警逻辑

### 9.4 第四阶段：API 开发（2-3天）

- [ ] 产品价格查询 API
- [ ] 供应商成本管理 API
- [ ] 服务阶段模板管理 API
- [ ] 订单供应商分配 API
- [ ] 进度预警查询 API

### 9.5 第五阶段：测试和优化（2天）

- [ ] 单元测试
- [ ] 集成测试
- [ ] 性能优化
- [ ] 文档完善

**预计总工作量**: 9-13天

---

## 十、注意事项

### 10.1 数据一致性

1. **价格唯一性**: 确保同一产品在同一客户等级下只有一个有效价格
2. **成本版本连续性**: 确保供应商成本版本的时间段连续且不重叠
3. **订单成本快照**: 订单创建后，成本快照不应再变更

### 10.2 性能优化

1. **索引优化**: 在常用查询字段上创建索引
2. **查询优化**: 使用 JOIN 替代子查询（如果可能）
3. **缓存策略**: 价格和成本信息可以缓存，定期更新

### 10.3 向后兼容

1. **旧价格字段**: 保留但不使用，等待数据迁移完成后删除
2. **API 版本**: 新 API 使用 `/api/v1/` 前缀，旧 API 保持兼容
3. **数据迁移**: 提供回滚方案，确保可以回退

### 10.4 扩展性考虑

1. **多币种支持**: 当前支持 CNY 和 IDR，未来可扩展支持 USD、EUR 等
2. **价格策略**: 未来可支持更复杂的价格策略（如：阶梯价格、促销价格）
3. **供应商评级**: 未来可添加供应商评级和选择算法

---

## 十一、待确认事项

### 11.1 业务规则确认

- [ ] 价格生效时间的最小粒度是多少？（小时、天、周）
- [ ] 供应商成本版本是否可以回退到历史版本？
- [ ] 订单创建后，如果供应商报价变更，是否允许重新分配供应商？
- [ ] 服务阶段模板是否可以自定义？还是只能使用系统预设？

### 11.2 技术方案确认

- [ ] 价格和成本数据是否需要实时同步？还是可以异步更新？
- [ ] 进度预警的检查频率是多少？（每小时、每天）
- [ ] 是否需要支持价格审批流程？
- [ ] 是否需要支持供应商报价的批量导入？

---

**文档版本**: v2.0  
**最后更新**: 2024-12-13  
**维护人**: 开发团队
