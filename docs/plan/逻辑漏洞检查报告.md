# 服务与供应商管理表结构 - 逻辑漏洞检查报告

**检查日期**: 2024-12-13  
**检查范围**: SQL表结构、业务逻辑、数据一致性

---

## 🔴 严重漏洞

### 1. product_price_list 表唯一索引设计缺陷

**问题位置**: `create_service_vendor_management_tables.sql` 第110行

**当前设计**:
```sql
UNIQUE KEY `ux_product_active` (`product_id`, `is_active`)
```

**问题描述**:
- 这个唯一索引允许一个产品有**两条记录**：一条 `is_active=1`，一条 `is_active=0`
- 但无法保留**历史价格版本**（如果需要保留多个历史版本）
- 如果价格更新时，需要先关闭旧记录（`is_active=0`），再创建新记录（`is_active=1`）
- 但这样会导致旧记录被覆盖，无法查询历史价格

**影响**:
- 无法查询历史价格记录
- 价格更新时可能丢失历史数据
- 如果业务需要价格审批流程，无法保留审批历史

**修复方案**:
```sql
-- 方案1：移除is_active，使用effective_from/effective_to控制生效时间
UNIQUE KEY `ux_product_active` (`product_id`),
-- 查询时：WHERE product_id = ? AND (effective_to IS NULL OR effective_to > NOW())

-- 方案2：允许历史记录存在，但确保只有一个有效记录（应用层保证）
-- 移除唯一索引，添加唯一索引只针对有效记录
CREATE UNIQUE INDEX `ux_product_active_only` ON `product_price_list` (`product_id`) 
WHERE `is_active` = 1;  -- MySQL不支持部分索引，需要应用层保证

-- 方案3：保留唯一索引，但添加历史表（推荐）
-- 当前表只保留当前有效价格，历史价格迁移到 product_price_history 表
```

**推荐方案**: 方案1 - 移除 `is_active` 字段，使用 `effective_from` 和 `effective_to` 控制生效时间

---

### 2. supplier_cost_history 版本号并发问题

**问题位置**: 文档中版本号生成逻辑

**当前设计**:
```sql
INSERT INTO supplier_cost_history (
  product_id, supplier_id, delivery_type, version, 
  ...
) VALUES (
  ?, ?, ?, 
  (SELECT COALESCE(MAX(version), 0) + 1 FROM supplier_cost_history WHERE product_id = ? AND supplier_id = ?),
  ...
)
```

**问题描述**:
- 使用子查询计算版本号，存在**并发问题**
- 如果两个用户同时更新同一供应商的成本价格，可能生成相同的版本号
- 虽然 `is_current` 可以保证只有一个当前版本，但版本号可能重复

**影响**:
- 版本号可能重复（虽然不影响功能，但不符合版本控制语义）
- 高并发场景下可能出现数据不一致

**修复方案**:
```sql
-- 方案1：使用事务 + SELECT FOR UPDATE（推荐）
BEGIN;
SELECT MAX(version) INTO @max_version FROM supplier_cost_history 
WHERE product_id = ? AND supplier_id = ? FOR UPDATE;
SET @new_version = COALESCE(@max_version, 0) + 1;
INSERT INTO supplier_cost_history (..., version, ...) VALUES (..., @new_version, ...);
COMMIT;

-- 方案2：使用应用层生成版本号（在事务中）
-- 应用层先查询最大版本号，加锁，然后插入

-- 方案3：使用AUTO_INCREMENT（不推荐，因为版本号是per product+supplier的）
```

**推荐方案**: 方案1 - 使用事务和行锁

---

### 3. delivery_type 与 supplier_id 的一致性检查缺失

**问题位置**: `order_items` 表检查约束

**当前设计**:
```sql
CONSTRAINT `chk_order_items_delivery` 
CHECK (
  (`selected_supplier_id` IS NULL AND `delivery_type` IS NULL) OR
  (`selected_supplier_id` IS NOT NULL AND `delivery_type` IS NOT NULL)
)
```

**问题描述**:
- 检查约束只保证两者同时存在或同时为空
- **但没有检查** `delivery_type` 是否与 `organizations.organization_type` 匹配
- 可能出现：`selected_supplier_id` 指向一个 `organization_type='vendor'` 的组织，但 `delivery_type='INTERNAL'`

**影响**:
- 数据不一致：内部交付但选择了外部供应商
- 利润核算错误：可能将供应商成本误认为内部成本

**修复方案**:
```sql
-- 方案1：添加触发器检查（推荐）
DELIMITER $$
CREATE TRIGGER `trg_order_items_check_delivery_type` 
BEFORE INSERT ON `order_items`
FOR EACH ROW
BEGIN
  IF NEW.selected_supplier_id IS NOT NULL THEN
    SET @org_type = (SELECT organization_type FROM organizations WHERE id = NEW.selected_supplier_id);
    IF (@org_type = 'vendor' AND NEW.delivery_type != 'VENDOR') OR
       (@org_type = 'internal' AND NEW.delivery_type != 'INTERNAL') THEN
      SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'delivery_type must match organization_type';
    END IF;
  END IF;
END$$
DELIMITER ;

-- 方案2：应用层保证（需要在所有插入/更新order_items的地方检查）
```

**推荐方案**: 方案1 - 添加触发器

---

## 🟡 中等风险

### 4. order_stages 表 order_item_id 与 order_id 的一致性

**问题位置**: `order_stages` 表

**当前设计**:
```sql
CHECK (`order_id` IS NOT NULL)
```

**问题描述**:
- 如果 `order_item_id` 不为空，应该检查 `order_item_id` 对应的 `order_id` 是否与 `order_stages.order_id` 一致
- 当前没有这个检查，可能出现数据不一致

**影响**:
- 订单阶段可能关联到错误的订单项
- 进度查询可能出现错误

**修复方案**:
```sql
-- 添加触发器检查
DELIMITER $$
CREATE TRIGGER `trg_order_stages_check_order_item` 
BEFORE INSERT ON `order_stages`
FOR EACH ROW
BEGIN
  IF NEW.order_item_id IS NOT NULL THEN
    SET @item_order_id = (SELECT order_id FROM order_items WHERE id = NEW.order_item_id);
    IF @item_order_id != NEW.order_id THEN
      SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'order_item_id must belong to the same order_id';
    END IF;
  END IF;
END$$
DELIMITER ;
```

---

### 5. supplier_cost_history 版本号更新逻辑不完整

**问题位置**: 文档中成本价格更新流程

**当前设计**:
- 更新成本价格时，需要先关闭旧版本，再创建新版本
- 但没有检查是否存在**重叠的有效时间段**

**问题描述**:
- 如果更新时没有正确关闭旧版本，可能出现两个 `is_current=1` 的记录
- 或者 `effective_start_at` 和 `effective_end_at` 时间段重叠

**影响**:
- 查询当前成本价格时可能返回多条记录
- 成本核算可能出现错误

**修复方案**:
```sql
-- 在更新成本价格时，确保：
-- 1. 关闭所有旧版本（不仅仅是当前版本）
-- 2. 检查时间段不重叠
-- 3. 使用事务保证原子性

BEGIN;
-- 关闭所有旧版本
UPDATE supplier_cost_history 
SET effective_end_at = NOW(), is_current = 0
WHERE product_id = ? 
  AND supplier_id = ? 
  AND (effective_end_at IS NULL OR effective_end_at > NOW());

-- 检查时间段不重叠（应用层检查）
-- 创建新版本
INSERT INTO supplier_cost_history (...);
COMMIT;
```

---

### 6. product_price_list 价格生效时间查询逻辑

**问题位置**: 文档中价格查询逻辑

**当前设计**:
```sql
WHERE product_id = ? 
  AND is_active = 1
  AND (effective_to IS NULL OR effective_to > NOW())
```

**问题描述**:
- 只检查了 `effective_to`，没有检查 `effective_from`
- 如果 `effective_from` 是未来时间，不应该返回该价格

**影响**:
- 可能返回尚未生效的价格
- 销售报价可能出现错误

**修复方案**:
```sql
WHERE product_id = ? 
  AND is_active = 1
  AND effective_from <= NOW()
  AND (effective_to IS NULL OR effective_to > NOW())
```

---

## 🟢 低风险（建议优化）

### 7. file_storage 表 business_id 可以为空

**问题位置**: `file_storage` 表

**当前设计**:
```sql
`business_id` CHAR(36) DEFAULT NULL COMMENT '业务对象ID（关联到具体的业务记录，如报销单ID、合同ID等）'
```

**问题描述**:
- `business_id` 可以为空，但 `business_type` 不能为空
- 如果 `business_id` 为空，文件无法关联到具体业务对象
- 可能导致"孤儿文件"（上传了但未关联到业务对象）

**影响**:
- 文件管理混乱
- 无法追踪文件用途

**修复方案**:
```sql
-- 根据业务需求决定：
-- 方案1：允许为空（如果支持先上传后关联）
-- 方案2：不允许为空（强制关联）
`business_id` CHAR(36) NOT NULL COMMENT '业务对象ID（必须关联到具体的业务记录）'
```

---

### 8. biz_expense_records 报销单号生成逻辑缺失

**问题位置**: `biz_expense_records` 表

**当前设计**:
```sql
`expense_no` VARCHAR(50) NOT NULL COMMENT '报销单号 (如 EXP-20231027-001)'
UNIQUE KEY `ux_expense_no` (`expense_no`)
```

**问题描述**:
- 报销单号需要唯一，但没有自动生成逻辑
- 如果应用层生成逻辑有问题，可能出现重复

**影响**:
- 报销单号可能重复
- 违反唯一约束导致插入失败

**修复方案**:
```sql
-- 方案1：使用数据库序列或自增（MySQL不支持，需要应用层实现）
-- 方案2：使用触发器生成（推荐）
DELIMITER $$
CREATE TRIGGER `trg_biz_expense_records_generate_no` 
BEFORE INSERT ON `biz_expense_records`
FOR EACH ROW
BEGIN
  IF NEW.expense_no IS NULL OR NEW.expense_no = '' THEN
    SET NEW.expense_no = CONCAT('EXP-', DATE_FORMAT(NOW(), '%Y%m%d'), '-', 
      LPAD((SELECT COALESCE(MAX(SUBSTRING(expense_no, -3)), 0) + 1 
            FROM biz_expense_records 
            WHERE DATE(created_at) = CURDATE()), 3, '0'));
  END IF;
END$$
DELIMITER ;
```

---

### 9. order_items 成本快照更新风险

**问题位置**: `order_items` 表

**当前设计**:
```sql
`snapshot_cost_cny` DECIMAL(18,2) DEFAULT '0.00' COMMENT '下单时的RMB成本快照'
`supplier_cost_history_id` CHAR(36) DEFAULT NULL COMMENT '关联的成本版本ID'
```

**问题描述**:
- `snapshot_cost_cny` 和 `supplier_cost_history_id` 应该保持一致
- 如果 `supplier_cost_history_id` 被更新，`snapshot_cost_cny` 也应该同步更新
- 当前没有约束保证一致性

**影响**:
- 可能出现成本快照与成本版本不一致
- 利润核算可能出现错误

**修复方案**:
```sql
-- 添加触发器保证一致性
DELIMITER $$
CREATE TRIGGER `trg_order_items_sync_cost_snapshot` 
BEFORE UPDATE ON `order_items`
FOR EACH ROW
BEGIN
  IF NEW.supplier_cost_history_id IS NOT NULL AND 
     (NEW.supplier_cost_history_id != OLD.supplier_cost_history_id OR 
      NEW.snapshot_cost_cny = 0) THEN
    SET NEW.snapshot_cost_cny = (
      SELECT cost_cny FROM supplier_cost_history 
      WHERE id = NEW.supplier_cost_history_id
    );
    SET NEW.snapshot_cost_idr = (
      SELECT cost_idr FROM supplier_cost_history 
      WHERE id = NEW.supplier_cost_history_id
    );
  END IF;
END$$
DELIMITER ;
```

---

### 10. service_stage_templates 阶段顺序连续性检查缺失

**问题位置**: `service_stage_templates` 表

**当前设计**:
```sql
CONSTRAINT `chk_stage_order_positive` CHECK (`stage_order` > 0)
```

**问题描述**:
- 只检查了 `stage_order > 0`，但没有检查连续性
- 可能出现：stage_order = 1, 3, 5（缺少2和4）
- 或者同一产品有多个 stage_order = 1 的记录

**影响**:
- 阶段模板不完整
- 进度计算可能出现错误

**修复方案**:
```sql
-- 添加唯一约束确保同一产品的阶段顺序不重复
ALTER TABLE `service_stage_templates`
ADD UNIQUE KEY `ux_stage_product_order` (`product_id`, `stage_order`);

-- 应用层检查连续性（确保stage_order从1开始连续）
```

---

## 📋 修复建议优先级

### 高优先级（必须修复）
1. ✅ **product_price_list 唯一索引设计** - 影响历史价格查询
2. ✅ **supplier_cost_history 版本号并发问题** - 影响数据一致性
3. ✅ **delivery_type 一致性检查** - 影响利润核算准确性

### 中优先级（建议修复）
4. ✅ **order_stages order_item_id 一致性** - 影响进度查询
5. ✅ **supplier_cost_history 版本更新逻辑** - 影响成本核算
6. ✅ **product_price_list 生效时间查询** - 影响销售报价

### 低优先级（可选优化）
7. ✅ **file_storage business_id 可为空** - 影响文件管理
8. ✅ **biz_expense_records 单号生成** - 影响数据完整性
9. ✅ **order_items 成本快照同步** - 影响利润核算
10. ✅ **service_stage_templates 顺序连续性** - 影响进度计算

---

## 🔧 修复后的完整SQL脚本

需要更新 `create_service_vendor_management_tables.sql` 文件，添加：
1. 修复 product_price_list 唯一索引
2. 添加触发器检查 delivery_type 一致性
3. 添加触发器检查 order_stages 一致性
4. 添加报销单号自动生成触发器
5. 添加成本快照同步触发器
6. 添加 service_stage_templates 唯一约束
