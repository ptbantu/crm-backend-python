# 1. 用户认证与登录

## 1.1 用户登录

### 核心业务逻辑说明
用户通过用户名/邮箱和密码进行登录，系统验证用户身份后生成JWT令牌，返回用户信息和权限。

### 详细业务逻辑

#### 1.1.1 登录流程
1. **接收登录请求**
   - 接收用户名/邮箱和密码
   - 验证请求参数格式

2. **验证用户身份**
   - 根据用户名或邮箱查询用户（`foundation_service/services/auth_service.py`）
   - 验证密码（使用bcrypt进行密码哈希验证）
   - 检查用户状态（`is_active`必须为`true`）
   - 检查用户所属组织状态（组织必须激活且未锁定）

3. **获取用户权限**
   - 查询用户所属组织（`organization_employees`表）
   - 查询用户角色（`user_roles`表）
   - 查询角色权限（`role_permissions`表）
   - 构建权限列表（包括菜单权限）

4. **生成JWT令牌**
   - 生成访问令牌（Access Token），包含用户ID、组织ID、角色列表
   - 生成刷新令牌（Refresh Token）
   - 设置令牌过期时间

5. **更新用户信息**
   - 更新用户最后登录时间（`last_login_at`）
   - 更新用户最后登录IP（`last_login_ip`）

6. **返回登录结果**
   - 返回用户基本信息
   - 返回访问令牌和刷新令牌
   - 返回用户角色和权限列表

### 关键文件路径
- **API端点**: `foundation_service/api/v1/auth.py` - `POST /api/v1/auth/login`
- **服务层**: `foundation_service/services/auth_service.py` - `AuthService.login()`
- **数据访问层**: `foundation_service/repositories/user_repository.py`
- **模型定义**: `common/models/user.py` - `User`
- **JWT工具**: `common/auth.py` - `create_access_token()`, `create_refresh_token()`

### 代码位置引用
```python
# foundation_service/services/auth_service.py
async def login(self, username: str, password: str, ip_address: str = None) -> LoginResponse:
    # 1. 查询用户
    user = await self.user_repo.get_by_username_or_email(username)
    if not user:
        raise BusinessException(detail="用户名或密码错误", status_code=401)
    
    # 2. 验证密码
    if not verify_password(password, user.password_hash):
        raise BusinessException(detail="用户名或密码错误", status_code=401)
    
    # 3. 检查用户状态
    if not user.is_active:
        raise BusinessException(detail="用户已被禁用", status_code=403)
    
    # 4. 检查组织状态
    org_employee = await self.org_employee_repo.get_by_user_id(user.id)
    if not org_employee or not org_employee.organization.is_active:
        raise BusinessException(detail="组织未激活", status_code=403)
    
    # 5. 获取角色和权限
    roles = await self.role_service.get_user_roles(user.id)
    permissions = await self.permission_service.get_user_permissions(user.id)
    
    # 6. 生成令牌
    access_token = create_access_token(
        user_id=user.id,
        organization_id=org_employee.organization_id,
        roles=[r.code for r in roles]
    )
    refresh_token = create_refresh_token(user_id=user.id)
    
    # 7. 更新登录信息
    user.last_login_at = datetime.utcnow()
    user.last_login_ip = ip_address
    await self.db.commit()
    
    return LoginResponse(...)
```

### 潜在问题与注意事项
1. **密码安全**: 密码使用bcrypt哈希存储，验证时使用`verify_password`函数
2. **组织状态检查**: 必须同时检查用户状态和组织状态
3. **权限缓存**: 权限信息可以缓存以提高性能
4. **登录失败处理**: 登录失败不应暴露具体原因（用户名不存在 vs 密码错误）

---

## 1.2 刷新令牌

### 核心业务逻辑说明
使用刷新令牌获取新的访问令牌，延长用户会话时间。

### 详细业务逻辑
1. **验证刷新令牌**
   - 解析刷新令牌，获取用户ID
   - 验证令牌有效性和过期时间

2. **生成新访问令牌**
   - 重新获取用户角色和权限
   - 生成新的访问令牌

3. **返回新令牌**
   - 返回新的访问令牌（刷新令牌保持不变）

### 关键文件路径
- **API端点**: `foundation_service/api/v1/auth.py` - `POST /api/v1/auth/refresh`
- **服务层**: `foundation_service/services/auth_service.py` - `AuthService.refresh_token()`

---

## 1.3 用户登出

### 核心业务逻辑说明
用户登出，可以选择性地使令牌失效（如果实现了令牌黑名单机制）。

### 详细业务逻辑
1. **接收登出请求**
   - 从请求头获取访问令牌

2. **可选：令牌失效**
   - 将令牌加入黑名单（如果实现了令牌管理）

3. **返回登出结果**

### 关键文件路径
- **API端点**: `foundation_service/api/v1/auth.py` - `POST /api/v1/auth/logout`
- **服务层**: `foundation_service/services/auth_service.py` - `AuthService.logout()`

---

## 1.4 JWT令牌解析

### 核心业务逻辑说明
从HTTP请求中提取JWT令牌，解析用户ID、组织ID和角色信息，用于后续的权限验证和数据隔离。

### 详细业务逻辑
1. **提取令牌**
   - 从请求头`Authorization`中提取Bearer令牌
   - 验证令牌格式

2. **解析令牌**
   - 使用JWT密钥验证令牌签名
   - 解析令牌载荷（payload）
   - 提取用户ID、组织ID、角色列表

3. **验证令牌有效性**
   - 检查令牌是否过期
   - 检查令牌是否在黑名单中（如果实现了）

### 关键文件路径
- **工具函数**: `common/auth.py`
  - `get_token_payload_from_request()` - 从请求中获取令牌载荷
  - `get_current_user_id_from_request()` - 获取当前用户ID
  - `get_current_user_roles_from_request()` - 获取当前用户角色
- **依赖注入**: `common/auth.py` - `get_current_user()`, `get_current_user_roles()`

### 代码位置引用
```python
# common/auth.py
def get_token_payload_from_request(
    request: Request, 
    settings: BaseServiceSettings
) -> Optional[Dict[str, Any]]:
    """从请求中提取并解析JWT令牌载荷"""
    token = extract_token_from_request(request)
    if not token:
        return None
    
    try:
        payload = jwt.decode(
            token,
            settings.jwt_secret_key,
            algorithms=[settings.jwt_algorithm]
        )
        return payload
    except jwt.ExpiredSignatureError:
        return None
    except jwt.InvalidTokenError:
        return None

def get_current_user_id_from_request(
    request: Request,
    settings: BaseServiceSettings
) -> Optional[str]:
    """从请求中获取当前用户ID"""
    payload = get_token_payload_from_request(request, settings)
    if not payload:
        return None
    return payload.get("sub")  # JWT标准中sub字段存储用户ID
```

### 潜在问题与注意事项
1. **非依赖注入函数**: 提供了`get_current_user_id_from_request`等函数，可以在非FastAPI依赖注入场景下直接调用
2. **错误处理**: 令牌解析失败应返回None，由调用方处理
3. **安全性**: 令牌密钥必须保密，不应暴露在客户端


