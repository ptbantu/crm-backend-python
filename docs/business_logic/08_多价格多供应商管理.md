# 多价格多供应商管理业务逻辑

**创建日期**: 2024-12-13  
**版本**: v1.0  
**状态**: 设计阶段

---

## 目录

1. [概述](#1-概述)
2. [核心概念](#2-核心概念)
3. [销售价格管理](#3-销售价格管理)
4. [成本价格管理](#4-成本价格管理)
5. [供应商选择逻辑](#5-供应商选择逻辑)
6. [订单创建与价格快照](#6-订单创建与价格快照)
7. [利润计算逻辑](#7-利润计算逻辑)
8. [价格版本更新流程](#8-价格版本更新流程)
9. [内部交付vs供应商交付](#9-内部交付vs供应商交付)
10. [API设计](#10-api设计)

---

## 1. 概述

### 1.1 业务目标

实现多价格多供应商管理，支持：
- **多供应商竞争**: 一个服务可以由多个供应商提供，支持供应商选择和竞争
- **内部交付**: 公司内部团队也可以提供服务
- **价格版本控制**: 成本价格和销售价格都支持版本控制，价格变更不影响历史订单
- **分级销售价格**: 根据客户等级设置不同的销售价格
- **精确利润核算**: 支持成本价格、销售价格、浮动成本的精确归集

### 1.2 核心表结构

| 表名 | 用途 | 关键字段 |
|------|------|----------|
| `products` | 产品/服务基础信息 | `std_duration_days`, `allow_multi_vendor`, `default_supplier_id` |
| `product_price_list` | 销售价格体系（对外售价） | `price_level2_cny/idr` ~ `price_level6_cny/idr` |
| `supplier_cost_history` | 成本价格版本控制（内部/供应商成本） | `cost_cny/idr`, `version`, `delivery_type` |
| `order_items` | 订单项（包含价格快照） | `selected_supplier_id`, `delivery_type`, `snapshot_cost_cny/idr` |
| `biz_expense_records` | 浮动成本（报销） | `cost_attribution`, `order_item_id` |

---

## 2. 核心概念

### 2.1 价格类型区分

#### 2.1.1 销售价格（Sales Price）

**定义**: 对外销售给客户的价格

**特点**:
- 根据客户等级分级设置（等级2-6）
- 存储在 `product_price_list` 表
- 一个产品一条记录，包含所有等级的价格
- 通过 `is_active` 和 `effective_from/effective_to` 控制生效时间

**查询场景**:
- 销售报价时查询
- 订单创建时确定销售价格

#### 2.1.2 成本价格（Cost Price）

**定义**: 内部团队或外部供应商提供服务的成本价格

**特点**:
- 由服务提供方（内部团队或外部供应商）提供
- 存储在 `supplier_cost_history` 表
- 支持版本控制，价格变更不影响历史订单
- 通过 `delivery_type` 区分内部交付（INTERNAL）和供应商交付（VENDOR）

**查询场景**:
- 供应商选择时查询
- 利润计算时查询
- 订单创建时快照成本价格

### 2.2 交付类型

| 交付类型 | 说明 | 提供方类型 | 成本来源 |
|---------|------|-----------|---------|
| `INTERNAL` | 内部交付 | `organization_type='internal'` | 内部团队成本 |
| `VENDOR` | 供应商交付 | `organization_type='vendor'` | 外部供应商成本 |

---

## 3. 销售价格管理

### 3.1 销售价格查询逻辑

**业务场景**: 销售需要为客户查询服务的销售价格（对外售价）

**输入参数**:
- `product_id`: 产品ID
- `customer_id`: 客户ID（用于获取客户等级）
- `currency`: 币种（CNY/IDR），可选，默认根据客户偏好

**查询流程**:

```python
def get_sales_price(product_id: str, customer_id: str, currency: str = None) -> dict:
    """
    查询销售价格
    
    步骤：
    1. 查询客户等级
    2. 查询产品的有效销售价格记录
    3. 根据客户等级和币种返回对应价格
    """
    # 1. 查询客户等级
    customer = get_customer(customer_id)
    level_code = customer.level_code  # 例如: '2', '3', '4', '5', '6'
    
    # 2. 查询产品的有效销售价格
    price_record = db.query(product_price_list).filter(
        product_price_list.product_id == product_id,
        product_price_list.is_active == True,
        product_price_list.effective_from <= now(),
        or_(
            product_price_list.effective_to.is_(None),
            product_price_list.effective_to > now()
        )
    ).first()
    
    if not price_record:
        raise NotFoundError("产品未设置销售价格")
    
    # 3. 根据客户等级和币种返回价格
    level_field_cny = f"price_level{level_code}_cny"
    level_field_idr = f"price_level{level_code}_idr"
    
    if currency == "CNY":
        return {
            "price_cny": getattr(price_record, level_field_cny),
            "price_idr": None
        }
    elif currency == "IDR":
        return {
            "price_cny": None,
            "price_idr": getattr(price_record, level_field_idr)
        }
    else:
        # 返回两种币种
        return {
            "price_cny": getattr(price_record, level_field_cny),
            "price_idr": getattr(price_record, level_field_idr)
        }
```

**返回结果**:
```json
{
  "product_id": "uuid",
  "customer_level": "3",
  "price_cny": "1500.00",
  "price_idr": "3000000.00",
  "effective_from": "2024-12-01T00:00:00",
  "effective_to": null
}
```

### 3.2 销售价格更新逻辑

**业务场景**: 更新产品的销售价格

**规则**:
1. 如果存在 `is_active=1` 的记录，必须先将其设置为 `is_active=0`
2. 创建新记录，设置 `is_active=1`
3. 或者直接更新现有记录（如果不需要保留历史）

**流程**:

```python
def update_sales_price(product_id: str, prices: dict, effective_from: datetime = None) -> dict:
    """
    更新销售价格
    
    参数：
    - prices: {
        "price_level2_cny": 2000.00,
        "price_level2_idr": 4000000.00,
        ...
      }
    """
    # 1. 关闭旧的价格记录
    old_price = db.query(product_price_list).filter(
        product_price_list.product_id == product_id,
        product_price_list.is_active == True
    ).first()
    
    if old_price:
        old_price.is_active = False
        old_price.effective_to = effective_from or now()
        db.commit()
    
    # 2. 创建新价格记录
    new_price = product_price_list(
        product_id=product_id,
        is_active=True,
        effective_from=effective_from or now(),
        effective_to=None,
        **prices
    )
    db.add(new_price)
    db.commit()
    
    return new_price
```

---

## 4. 成本价格管理

### 4.1 成本价格查询逻辑

**业务场景**: 查询服务提供方（内部团队或外部供应商）的成本价格

**输入参数**:
- `product_id`: 产品ID
- `supplier_id`: 服务提供方ID（内部团队或外部供应商）
- `delivery_type`: 交付类型（INTERNAL/VENDOR），可选，如果不提供则自动判断

**查询流程**:

```python
def get_cost_price(product_id: str, supplier_id: str, delivery_type: str = None) -> dict:
    """
    查询当前成本价格
    
    步骤：
    1. 如果未提供delivery_type，根据supplier_id查询组织类型自动判断
    2. 查询当前有效的成本价格版本
    """
    # 1. 自动判断交付类型
    if not delivery_type:
        supplier = get_organization(supplier_id)
        if supplier.organization_type == 'internal':
            delivery_type = 'INTERNAL'
        elif supplier.organization_type == 'vendor':
            delivery_type = 'VENDOR'
        else:
            raise ValueError(f"组织类型 {supplier.organization_type} 不能作为服务提供方")
    
    # 2. 查询当前有效的成本价格
    cost_record = db.query(supplier_cost_history).filter(
        supplier_cost_history.product_id == product_id,
        supplier_cost_history.supplier_id == supplier_id,
        supplier_cost_history.delivery_type == delivery_type,
        supplier_cost_history.is_current == True,
        supplier_cost_history.effective_start_at <= now(),
        or_(
            supplier_cost_history.effective_end_at.is_(None),
            supplier_cost_history.effective_end_at > now()
        )
    ).first()
    
    if not cost_record:
        raise NotFoundError(f"产品 {product_id} 的服务提供方 {supplier_id} 未设置成本价格")
    
    return {
        "id": cost_record.id,
        "product_id": cost_record.product_id,
        "supplier_id": cost_record.supplier_id,
        "delivery_type": cost_record.delivery_type,
        "version": cost_record.version,
        "cost_cny": cost_record.cost_cny,
        "cost_idr": cost_record.cost_idr,
        "effective_start_at": cost_record.effective_start_at,
        "effective_end_at": cost_record.effective_end_at
    }
```

### 4.2 成本价格版本更新逻辑

**业务场景**: 更新服务提供方的成本价格（创建新版本）

**规则**:
1. 使用事务和行锁防止并发问题
2. 关闭所有旧版本（不仅仅是当前版本），防止时间段重叠
3. 版本号自动递增

**流程**:

```python
def update_cost_price(
    product_id: str,
    supplier_id: str,
    delivery_type: str,
    cost_cny: Decimal,
    cost_idr: Decimal,
    effective_from: datetime = None,
    notes: str = None
) -> dict:
    """
    更新成本价格（创建新版本）
    
    步骤：
    1. 开启事务
    2. 关闭所有旧版本
    3. 查询最大版本号（加锁）
    4. 创建新版本
    """
    with db.begin():
        # 1. 关闭所有旧版本
        db.query(supplier_cost_history).filter(
            supplier_cost_history.product_id == product_id,
            supplier_cost_history.supplier_id == supplier_id,
            or_(
                supplier_cost_history.effective_end_at.is_(None),
                supplier_cost_history.effective_end_at > now()
            )
        ).update({
            "effective_end_at": effective_from or now(),
            "is_current": False
        })
        
        # 2. 查询最大版本号（加锁）
        max_version = db.query(func.max(supplier_cost_history.version)).filter(
            supplier_cost_history.product_id == product_id,
            supplier_cost_history.supplier_id == supplier_id
        ).with_for_update().scalar() or 0
        
        new_version = max_version + 1
        
        # 3. 创建新版本
        new_cost = supplier_cost_history(
            product_id=product_id,
            supplier_id=supplier_id,
            delivery_type=delivery_type,
            version=new_version,
            cost_cny=cost_cny,
            cost_idr=cost_idr,
            effective_start_at=effective_from or now(),
            effective_end_at=None,
            is_current=True,
            notes=notes
        )
        db.add(new_cost)
        db.commit()
        
        return new_cost
```

---

## 5. 供应商选择逻辑

### 5.1 获取可选供应商列表

**业务场景**: 查询可以为某个产品提供服务的所有供应商（包括内部团队）

**输入参数**:
- `product_id`: 产品ID

**查询流程**:

```python
def get_available_suppliers(product_id: str) -> list:
    """
    获取可选供应商列表
    
    返回：
    - 内部团队（如果设置了成本价格）
    - 外部供应商（如果设置了成本价格）
    """
    # 查询所有设置了成本价格的服务提供方
    suppliers = db.query(
        supplier_cost_history.supplier_id,
        organizations.name,
        organizations.organization_type,
        supplier_cost_history.delivery_type,
        supplier_cost_history.cost_cny,
        supplier_cost_history.cost_idr,
        supplier_cost_history.version
    ).join(
        organizations,
        supplier_cost_history.supplier_id == organizations.id
    ).filter(
        supplier_cost_history.product_id == product_id,
        supplier_cost_history.is_current == True,
        supplier_cost_history.effective_start_at <= now(),
        or_(
            supplier_cost_history.effective_end_at.is_(None),
            supplier_cost_history.effective_end_at > now()
        )
    ).all()
    
    result = []
    for s in suppliers:
        result.append({
            "supplier_id": s.supplier_id,
            "supplier_name": s.name,
            "organization_type": s.organization_type,
            "delivery_type": s.delivery_type,
            "cost_cny": s.cost_cny,
            "cost_idr": s.cost_idr,
            "version": s.version
        })
    
    return result
```

**返回结果**:
```json
[
  {
    "supplier_id": "uuid-internal",
    "supplier_name": "内部执行团队",
    "organization_type": "internal",
    "delivery_type": "INTERNAL",
    "cost_cny": "2000.00",
    "cost_idr": "4000000.00",
    "version": 3
  },
  {
    "supplier_id": "uuid-vendor-1",
    "supplier_name": "供应商A",
    "organization_type": "vendor",
    "delivery_type": "VENDOR",
    "cost_cny": "1800.00",
    "cost_idr": "3600000.00",
    "version": 2
  }
]
```

### 5.2 供应商选择规则

**规则**:
1. 如果 `products.allow_multi_vendor = False`，只能选择 `products.default_supplier_id`
2. 如果 `products.allow_multi_vendor = True`，可以选择任意设置了成本价格的供应商
3. 优先选择成本价格较低的供应商（可选策略）

**选择逻辑**:

```python
def select_supplier(product_id: str, preferred_supplier_id: str = None) -> dict:
    """
    选择供应商
    
    规则：
    1. 如果指定了preferred_supplier_id，优先使用
    2. 如果产品不允许多供应商，使用默认供应商
    3. 否则选择成本最低的供应商
    """
    product = get_product(product_id)
    
    # 1. 如果不允许多供应商，使用默认供应商
    if not product.allow_multi_vendor:
        if product.default_supplier_id:
            return get_cost_price(product_id, product.default_supplier_id)
        else:
            raise ValueError("产品不允许多供应商但未设置默认供应商")
    
    # 2. 获取所有可选供应商
    suppliers = get_available_suppliers(product_id)
    
    if not suppliers:
        raise NotFoundError("没有可用的服务提供方")
    
    # 3. 如果指定了供应商，使用指定的
    if preferred_supplier_id:
        for s in suppliers:
            if s["supplier_id"] == preferred_supplier_id:
                return s
        raise ValueError(f"指定的供应商 {preferred_supplier_id} 不可用")
    
    # 4. 选择成本最低的供应商（CNY）
    suppliers.sort(key=lambda x: x["cost_cny"] or float('inf'))
    return suppliers[0]
```

---

## 6. 订单创建与价格快照

### 6.1 订单项创建流程

**业务场景**: 创建订单项时，需要快照销售价格和成本价格

**输入参数**:
- `order_id`: 订单ID
- `product_id`: 产品ID
- `customer_id`: 客户ID（用于查询销售价格）
- `selected_supplier_id`: 选定的服务提供方ID（可选）
- `quantity`: 数量

**创建流程**:

```python
def create_order_item(
    order_id: str,
    product_id: str,
    customer_id: str,
    selected_supplier_id: str = None,
    quantity: int = 1
) -> dict:
    """
    创建订单项（包含价格快照）
    
    步骤：
    1. 查询销售价格（根据客户等级）
    2. 选择或验证供应商
    3. 查询成本价格
    4. 计算预估毛利
    5. 创建订单项（快照价格）
    """
    # 1. 查询销售价格
    sales_price = get_sales_price(product_id, customer_id)
    
    # 2. 选择供应商
    if selected_supplier_id:
        supplier_cost = get_cost_price(product_id, selected_supplier_id)
        # 验证供应商是否可用
        available_suppliers = get_available_suppliers(product_id)
        if not any(s["supplier_id"] == selected_supplier_id for s in available_suppliers):
            raise ValueError("指定的供应商不可用")
    else:
        supplier_cost = select_supplier(product_id)
        selected_supplier_id = supplier_cost["supplier_id"]
    
    # 3. 确定交付类型
    supplier = get_organization(selected_supplier_id)
    if supplier.organization_type == 'internal':
        delivery_type = 'INTERNAL'
    elif supplier.organization_type == 'vendor':
        delivery_type = 'VENDOR'
    else:
        raise ValueError("无效的服务提供方类型")
    
    # 4. 计算预估毛利
    unit_price_cny = sales_price["price_cny"] or 0
    unit_price_idr = sales_price["price_idr"] or 0
    cost_cny = supplier_cost["cost_cny"] or 0
    cost_idr = supplier_cost["cost_idr"] or 0
    
    estimated_profit_cny = (unit_price_cny - cost_cny) * quantity
    estimated_profit_idr = (unit_price_idr - cost_idr) * quantity
    
    # 5. 创建订单项
    order_item = order_items(
        order_id=order_id,
        product_id=product_id,
        quantity=quantity,
        unit_price=unit_price_cny if sales_price["price_cny"] else unit_price_idr,
        currency_code="CNY" if sales_price["price_cny"] else "IDR",
        item_amount=(unit_price_cny if sales_price["price_cny"] else unit_price_idr) * quantity,
        
        # 供应商和成本信息
        selected_supplier_id=selected_supplier_id,
        delivery_type=delivery_type,
        supplier_cost_history_id=supplier_cost["id"],
        snapshot_cost_cny=cost_cny,
        snapshot_cost_idr=cost_idr,
        estimated_profit_cny=estimated_profit_cny,
        estimated_profit_idr=estimated_profit_idr
    )
    
    db.add(order_item)
    db.commit()
    
    return order_item
```

### 6.2 价格快照的作用

**目的**: 确保历史订单的成本价格不受后续价格变更影响

**规则**:
1. 订单创建时，快照当前的销售价格和成本价格
2. 即使后续价格变更，订单项的快照价格保持不变
3. 利润核算基于快照价格，确保历史订单的利润计算准确

---

## 7. 利润计算逻辑

### 7.1 订单项利润计算

**公式**:
```
订单项利润 = 销售价格 - 成本价格 - 浮动成本（报销）
```

**计算流程**:

```python
def calculate_order_item_profit(order_item_id: str) -> dict:
    """
    计算订单项利润
    
    步骤：
    1. 获取订单项信息（包含价格快照）
    2. 查询关联的报销记录（浮动成本）
    3. 计算利润
    """
    order_item = get_order_item(order_item_id)
    
    # 1. 销售价格（从订单项的快照）
    sales_price_cny = order_item.unit_price if order_item.currency_code == "CNY" else 0
    sales_price_idr = order_item.unit_price if order_item.currency_code == "IDR" else 0
    
    # 2. 成本价格（从快照）
    cost_cny = order_item.snapshot_cost_cny or 0
    cost_idr = order_item.snapshot_cost_idr or 0
    
    # 3. 浮动成本（报销）
    expenses = db.query(biz_expense_records).filter(
        biz_expense_records.order_item_id == order_item_id,
        biz_expense_records.cost_attribution == 'EXECUTION',
        biz_expense_records.status == 'PAID'  # 只计算已支付的报销
    ).all()
    
    expense_cny = sum(e.amount for e in expenses if e.currency == 'CNY')
    expense_idr = sum(e.amount for e in expenses if e.currency == 'IDR')
    
    # 4. 计算利润
    profit_cny = (sales_price_cny - cost_cny) * order_item.quantity - expense_cny
    profit_idr = (sales_price_idr - cost_idr) * order_item.quantity - expense_idr
    
    return {
        "order_item_id": order_item_id,
        "sales_price_cny": sales_price_cny,
        "sales_price_idr": sales_price_idr,
        "cost_cny": cost_cny,
        "cost_idr": cost_idr,
        "expense_cny": expense_cny,
        "expense_idr": expense_idr,
        "profit_cny": profit_cny,
        "profit_idr": profit_idr,
        "profit_rate_cny": profit_cny / sales_price_cny if sales_price_cny > 0 else 0,
        "profit_rate_idr": profit_idr / sales_price_idr if sales_price_idr > 0 else 0
    }
```

### 7.2 订单级利润计算

**公式**:
```
订单利润 = Σ(订单项利润) - 订单级浮动成本（报销）
```

**计算流程**:

```python
def calculate_order_profit(order_id: str) -> dict:
    """
    计算订单总利润
    
    步骤：
    1. 计算所有订单项的利润
    2. 查询订单级的报销记录
    3. 汇总计算
    """
    order_items_list = db.query(order_items).filter(
        order_items.order_id == order_id
    ).all()
    
    total_profit_cny = 0
    total_profit_idr = 0
    total_sales_cny = 0
    total_sales_idr = 0
    
    for item in order_items_list:
        item_profit = calculate_order_item_profit(item.id)
        total_profit_cny += item_profit["profit_cny"]
        total_profit_idr += item_profit["profit_idr"]
        total_sales_cny += item_profit["sales_price_cny"] * item.quantity
        total_sales_idr += item_profit["sales_price_idr"] * item.quantity
    
    # 订单级浮动成本（报销）
    order_expenses = db.query(biz_expense_records).filter(
        biz_expense_records.order_id == order_id,
        biz_expense_records.cost_attribution == 'SALES',
        biz_expense_records.status == 'PAID'
    ).all()
    
    order_expense_cny = sum(e.amount for e in order_expenses if e.currency == 'CNY')
    order_expense_idr = sum(e.amount for e in order_expenses if e.currency == 'IDR')
    
    final_profit_cny = total_profit_cny - order_expense_cny
    final_profit_idr = total_profit_idr - order_expense_idr
    
    return {
        "order_id": order_id,
        "total_sales_cny": total_sales_cny,
        "total_sales_idr": total_sales_idr,
        "total_profit_cny": final_profit_cny,
        "total_profit_idr": final_profit_idr,
        "profit_rate_cny": final_profit_cny / total_sales_cny if total_sales_cny > 0 else 0,
        "profit_rate_idr": final_profit_idr / total_sales_idr if total_sales_idr > 0 else 0
    }
```

---

## 8. 价格版本更新流程

### 8.1 销售价格更新流程

**场景**: 产品价格调整

**流程**:
1. 查询当前有效价格记录
2. 关闭旧记录（设置 `is_active=0`, `effective_to=now()`）
3. 创建新记录（设置 `is_active=1`, `effective_from=now()`）

**影响分析**:
- **新订单**: 自动使用新价格
- **旧订单**: 价格快照保持不变，不受影响

### 8.2 成本价格更新流程

**场景**: 供应商成本价格调整

**流程**:
1. 开启事务
2. 关闭所有旧版本（设置 `effective_end_at`, `is_current=0`）
3. 查询最大版本号（加锁）
4. 创建新版本（版本号+1）

**影响分析**:
- **新订单**: 自动关联到新成本价格版本
- **旧订单**: `order_items.supplier_cost_history_id` 仍指向旧版本，成本快照不变

---

## 9. 内部交付vs供应商交付

### 9.1 内部交付流程

**特点**:
- 服务由公司内部团队执行
- 成本价格由内部团队设置
- `delivery_type = 'INTERNAL'`
- `selected_supplier_id` 指向 `organization_type='internal'` 的组织

**适用场景**:
- 公司有专业团队可以执行的服务
- 需要保证服务质量和服务标准
- 成本可控的服务

### 9.2 供应商交付流程

**特点**:
- 服务外包给外部供应商执行
- 成本价格由供应商提供
- `delivery_type = 'VENDOR'`
- `selected_supplier_id` 指向 `organization_type='vendor'` 的组织

**适用场景**:
- 公司没有专业团队的服务
- 需要快速扩展服务能力
- 供应商有成本优势的服务

### 9.3 混合交付

**场景**: 一个订单项可以选择内部交付或供应商交付

**规则**:
- 订单创建时，可以选择内部交付或供应商交付
- 选择依据：成本、质量、时效等因素
- 系统自动验证 `delivery_type` 与 `selected_supplier_id` 的一致性

---

## 10. API设计

### 10.1 销售价格API

#### 10.1.1 查询销售价格

```
GET /api/foundation/products/{product_id}/sales-price?customer_id={customer_id}&currency={CNY|IDR}
```

**响应**:
```json
{
  "code": 200,
  "data": {
    "product_id": "uuid",
    "customer_level": "3",
    "price_cny": "1500.00",
    "price_idr": "3000000.00"
  }
}
```

#### 10.1.2 更新销售价格

```
PUT /api/foundation/products/{product_id}/sales-price
```

**请求体**:
```json
{
  "price_level2_cny": 2000.00,
  "price_level2_idr": 4000000.00,
  "price_level3_cny": 1500.00,
  "price_level3_idr": 3000000.00,
  ...
  "effective_from": "2025-01-01T00:00:00Z"
}
```

### 10.2 成本价格API

#### 10.2.1 查询成本价格

```
GET /api/foundation/providers/{provider_id}/products/{product_id}/cost-price
```

**响应**:
```json
{
  "code": 200,
  "data": {
    "id": "uuid",
    "product_id": "uuid",
    "supplier_id": "uuid",
    "delivery_type": "VENDOR",
    "version": 3,
    "cost_cny": "1800.00",
    "cost_idr": "3600000.00",
    "effective_start_at": "2024-12-01T00:00:00Z",
    "effective_end_at": null
  }
}
```

#### 10.2.2 更新成本价格

```
POST /api/foundation/providers/{provider_id}/products/{product_id}/cost-price
```

**请求体**:
```json
{
  "delivery_type": "VENDOR",
  "cost_cny": "2000.00",
  "cost_idr": "4000000.00",
  "effective_from": "2025-01-01T00:00:00Z",
  "notes": "下个月涨价"
}
```

### 10.3 供应商选择API

#### 10.3.1 获取可选供应商列表

```
GET /api/foundation/products/{product_id}/suppliers
```

**响应**:
```json
{
  "code": 200,
  "data": [
    {
      "supplier_id": "uuid",
      "supplier_name": "内部执行团队",
      "delivery_type": "INTERNAL",
      "cost_cny": "2000.00",
      "cost_idr": "4000000.00"
    },
    {
      "supplier_id": "uuid",
      "supplier_name": "供应商A",
      "delivery_type": "VENDOR",
      "cost_cny": "1800.00",
      "cost_idr": "3600000.00"
    }
  ]
}
```

### 10.4 订单项API（已更新）

#### 10.4.1 创建订单项

```
POST /api/order-workflow/order-items
```

**请求体**（新增字段）:
```json
{
  "order_id": "uuid",
  "product_id": "uuid",
  "selected_supplier_id": "uuid",      // 新增
  "delivery_type": "VENDOR",           // 新增
  "quantity": 1
}
```

**响应**（新增字段）:
```json
{
  "code": 200,
  "data": {
    "id": "uuid",
    "selected_supplier_id": "uuid",           // 新增
    "delivery_type": "VENDOR",               // 新增
    "supplier_cost_history_id": "uuid",       // 新增
    "snapshot_cost_cny": "1800.00",          // 新增
    "snapshot_cost_idr": "3600000.00",       // 新增
    "estimated_profit_cny": "200.00",        // 新增
    "estimated_profit_idr": "400000.00"      // 新增
  }
}
```

### 10.5 利润计算API

#### 10.5.1 计算订单项利润

```
GET /api/order-workflow/order-items/{item_id}/profit
```

**响应**:
```json
{
  "code": 200,
  "data": {
    "order_item_id": "uuid",
    "sales_price_cny": "2000.00",
    "cost_cny": "1800.00",
    "expense_cny": "50.00",
    "profit_cny": "150.00",
    "profit_rate_cny": 0.075
  }
}
```

#### 10.5.2 计算订单利润

```
GET /api/order-workflow/orders/{order_id}/profit
```

**响应**:
```json
{
  "code": 200,
  "data": {
    "order_id": "uuid",
    "total_sales_cny": "2000.00",
    "total_profit_cny": "150.00",
    "profit_rate_cny": 0.075
  }
}
```

---

## 11. 错误处理

### 11.1 常见错误场景

| 错误场景 | 错误码 | 错误信息 |
|---------|--------|---------|
| 产品未设置销售价格 | 404 | "产品未设置销售价格" |
| 服务提供方未设置成本价格 | 404 | "服务提供方未设置成本价格" |
| 指定的供应商不可用 | 400 | "指定的供应商不可用" |
| 产品不允许多供应商但未设置默认供应商 | 400 | "产品不允许多供应商但未设置默认供应商" |
| delivery_type与supplier_id不匹配 | 400 | "delivery_type必须与supplier_id的组织类型匹配" |

### 11.2 数据验证规则

1. **供应商选择验证**:
   - `selected_supplier_id` 必须指向设置了成本价格的供应商
   - `delivery_type` 必须与 `selected_supplier_id` 的组织类型匹配

2. **价格验证**:
   - 销售价格和成本价格必须 >= 0
   - 价格版本更新时，必须关闭旧版本

3. **订单项验证**:
   - 创建订单项时，必须快照成本价格
   - `supplier_cost_history_id` 必须有效

---

## 12. 实施计划

### 12.1 第一阶段：基础功能（已完成）

- [x] 数据库表结构设计
- [x] 数据库迁移脚本
- [x] 模型和Schema更新
- [x] API文档更新

### 12.2 第二阶段：业务逻辑实现（进行中）

- [ ] 销售价格查询服务
- [ ] 成本价格查询服务
- [ ] 供应商选择服务
- [ ] 订单项创建逻辑（价格快照）
- [ ] 利润计算服务

### 12.3 第三阶段：API实现

- [ ] 销售价格API
- [ ] 成本价格API
- [ ] 供应商选择API
- [ ] 利润计算API
- [ ] 订单项API更新

### 12.4 第四阶段：测试和优化

- [ ] 单元测试
- [ ] 集成测试
- [ ] 性能优化
- [ ] 文档完善

---

**更新日期**: 2024-12-13  
**版本**: v1.0
